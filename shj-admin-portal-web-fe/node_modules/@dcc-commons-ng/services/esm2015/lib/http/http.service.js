/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */
var HttpService_1;
import { __decorate, __metadata, __param } from "tslib";
import { Inject, Injectable, InjectionToken, Injector, Optional } from '@angular/core';
import { HttpClient, HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http';
import { ErrorHandlerInterceptor } from './error-handler.interceptor';
import { CacheInterceptor } from './cache.interceptor';
import { ApiPrefixInterceptor } from './api-prefix.interceptor';
import { JwtInterceptor } from './jwt.interceptor';
import { CsrfInterceptor } from "./csrf.interceptor";
import { MockInterceptor } from "./mock.interceptor";
// From @angular/common/http/src/interceptor: allows to chain interceptors
class HttpInterceptorHandler {
    constructor(next, interceptor) {
        this.next = next;
        this.interceptor = interceptor;
    }
    handle(request) {
        return this.interceptor.intercept(request, this.next);
    }
}
/**
 * Allows to override default dynamic interceptors that can be disabled with the HttpService extension.
 * Except for very specific needs, you should better configure these interceptors directly in the constructor below
 * for better readability.
 *
 * For static interceptors that should always be enabled (like ApiPrefixInterceptor), use the standard
 * HTTP_INTERCEPTORS token.
 */
export const HTTP_DYNAMIC_INTERCEPTORS = new InjectionToken('HTTP_DYNAMIC_INTERCEPTORS');
/**
 * Extends HttpClient with per request configuration using dynamic interceptors.
 */
let HttpService = HttpService_1 = class HttpService extends HttpClient {
    constructor(httpHandler, injector, interceptors = []) {
        super(httpHandler);
        this.httpHandler = httpHandler;
        this.injector = injector;
        this.interceptors = interceptors;
        if (!this.interceptors) {
            // Configure default interceptors that can be disabled here
            this.interceptors = [
                this.injector.get(ApiPrefixInterceptor),
                this.injector.get(ErrorHandlerInterceptor),
                this.injector.get(MockInterceptor),
                this.injector.get(JwtInterceptor),
                this.injector.get(CsrfInterceptor)
            ];
        }
    }
    cache(forceUpdate) {
        const cacheInterceptor = this.injector.get(CacheInterceptor).configure({ update: forceUpdate });
        return this.addInterceptor(cacheInterceptor);
    }
    skipErrorHandler() {
        return this.removeInterceptor(ErrorHandlerInterceptor);
    }
    disableApiPrefix() {
        return this.removeInterceptor(ApiPrefixInterceptor);
    }
    disableDefaultMock() {
        return this.removeInterceptor(MockInterceptor);
    }
    addMock(mockInterceptor) {
        return this.addInterceptor(mockInterceptor);
    }
    // Override the original method to wire interceptors when triggering the request.
    request(method, url, options) {
        const handler = this.interceptors.reduceRight((next, interceptor) => new HttpInterceptorHandler(next, interceptor), this.httpHandler);
        return new HttpClient(handler).request(method, url, options);
    }
    removeInterceptor(interceptorType) {
        return new HttpService_1(this.httpHandler, this.injector, this.interceptors.filter(i => !(i instanceof interceptorType)));
    }
    addInterceptor(interceptor) {
        return new HttpService_1(this.httpHandler, this.injector, this.interceptors.concat([interceptor]));
    }
};
HttpService.ctorParameters = () => [
    { type: HttpHandler },
    { type: Injector },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [HTTP_DYNAMIC_INTERCEPTORS,] }] }
];
HttpService = HttpService_1 = __decorate([
    Injectable(),
    __param(2, Optional()), __param(2, Inject(HTTP_DYNAMIC_INTERCEPTORS)),
    __metadata("design:paramtypes", [HttpHandler,
        Injector, Array])
], HttpService);
export { HttpService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHR0cC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGRjYy1jb21tb25zLW5nL3NlcnZpY2VzLyIsInNvdXJjZXMiOlsibGliL2h0dHAvaHR0cC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztHQUVHOzs7QUFFSCxPQUFPLEVBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUNyRixPQUFPLEVBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsZUFBZSxFQUFFLFdBQVcsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBR3RHLE9BQU8sRUFBQyx1QkFBdUIsRUFBQyxNQUFNLDZCQUE2QixDQUFDO0FBQ3BFLE9BQU8sRUFBQyxnQkFBZ0IsRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBQ3JELE9BQU8sRUFBQyxvQkFBb0IsRUFBQyxNQUFNLDBCQUEwQixDQUFDO0FBQzlELE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUNqRCxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDbkQsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBaUNuRCwwRUFBMEU7QUFDMUUsTUFBTSxzQkFBc0I7SUFFMUIsWUFBb0IsSUFBaUIsRUFBVSxXQUE0QjtRQUF2RCxTQUFJLEdBQUosSUFBSSxDQUFhO1FBQVUsZ0JBQVcsR0FBWCxXQUFXLENBQWlCO0lBQzNFLENBQUM7SUFFRCxNQUFNLENBQUMsT0FBeUI7UUFDOUIsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3hELENBQUM7Q0FFRjtBQUVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSx5QkFBeUIsR0FBRyxJQUFJLGNBQWMsQ0FBa0IsMkJBQTJCLENBQUMs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RTtJQUtFLFdBQUEsUUFBUSxFQUFFLENBQUEsRUFBRSxXQUFBLE1BQU0sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFBO3FDQUZ6QixXQUFXO1FBQ2QsUUFBUTtHQUgzQixXQUFXLENBaUV2QjtTQWpFWSxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBFTE0uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuaW1wb3J0IHtJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBJbmplY3RvciwgT3B0aW9uYWx9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtIdHRwQ2xpZW50LCBIdHRwRXZlbnQsIEh0dHBIYW5kbGVyLCBIdHRwSW50ZXJjZXB0b3IsIEh0dHBSZXF1ZXN0fSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQge0Vycm9ySGFuZGxlckludGVyY2VwdG9yfSBmcm9tICcuL2Vycm9yLWhhbmRsZXIuaW50ZXJjZXB0b3InO1xuaW1wb3J0IHtDYWNoZUludGVyY2VwdG9yfSBmcm9tICcuL2NhY2hlLmludGVyY2VwdG9yJztcbmltcG9ydCB7QXBpUHJlZml4SW50ZXJjZXB0b3J9IGZyb20gJy4vYXBpLXByZWZpeC5pbnRlcmNlcHRvcic7XG5pbXBvcnQge0p3dEludGVyY2VwdG9yfSBmcm9tICcuL2p3dC5pbnRlcmNlcHRvcic7XG5pbXBvcnQge0NzcmZJbnRlcmNlcHRvcn0gZnJvbSBcIi4vY3NyZi5pbnRlcmNlcHRvclwiO1xuaW1wb3J0IHtNb2NrSW50ZXJjZXB0b3J9IGZyb20gXCIuL21vY2suaW50ZXJjZXB0b3JcIjtcblxuLy8gSHR0cENsaWVudCBpcyBkZWNsYXJlZCBpbiBhIHJlLWV4cG9ydGVkIG1vZHVsZSwgc28gd2UgaGF2ZSB0byBleHRlbmQgdGhlIG9yaWdpbmFsIG1vZHVsZSB0byBtYWtlIGl0IHdvcmsgcHJvcGVybHlcbi8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMzg5NylcbmRlY2xhcmUgbW9kdWxlICdAYW5ndWxhci9jb21tb24vaHR0cC9odHRwJyB7XG5cbiAgLy8gQXVnbWVudCBIdHRwQ2xpZW50IHdpdGggdGhlIGFkZGVkIGNvbmZpZ3VyYXRpb24gbWV0aG9kcyBmcm9tIEh0dHBTZXJ2aWNlLCB0byBhbGxvdyBpbi1wbGFjZSByZXBsYWNlbWVudCBvZlxuICAvLyBIdHRwQ2xpZW50IHdpdGggSHR0cFNlcnZpY2UgdXNpbmcgZGVwZW5kZW5jeSBpbmplY3Rpb25cbiAgZXhwb3J0IGludGVyZmFjZSBIdHRwQ2xpZW50IHtcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgY2FjaGluZyBmb3IgdGhpcyByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VVcGRhdGUgRm9yY2VzIHJlcXVlc3QgdG8gYmUgbWFkZSBhbmQgdXBkYXRlcyBjYWNoZSBlbnRyeS5cbiAgICAgKiBAcmV0dXJuIHtIdHRwQ2xpZW50fSBUaGUgbmV3IGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNhY2hlKGZvcmNlVXBkYXRlPzogYm9vbGVhbik6IEh0dHBDbGllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBTa2lwcyBkZWZhdWx0IGVycm9yIGhhbmRsZXIgZm9yIHRoaXMgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIHtIdHRwQ2xpZW50fSBUaGUgbmV3IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHNraXBFcnJvckhhbmRsZXIoKTogSHR0cENsaWVudDtcblxuICAgIC8qKlxuICAgICAqIERvIG5vdCB1c2UgQVBJIHByZWZpeCBmb3IgdGhpcyByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4ge0h0dHBDbGllbnR9IFRoZSBuZXcgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZGlzYWJsZUFwaVByZWZpeCgpOiBIdHRwQ2xpZW50O1xuXG4gIH1cblxufVxuXG4vLyBGcm9tIEBhbmd1bGFyL2NvbW1vbi9odHRwL3NyYy9pbnRlcmNlcHRvcjogYWxsb3dzIHRvIGNoYWluIGludGVyY2VwdG9yc1xuY2xhc3MgSHR0cEludGVyY2VwdG9ySGFuZGxlciBpbXBsZW1lbnRzIEh0dHBIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG5leHQ6IEh0dHBIYW5kbGVyLCBwcml2YXRlIGludGVyY2VwdG9yOiBIdHRwSW50ZXJjZXB0b3IpIHtcbiAgfVxuXG4gIGhhbmRsZShyZXF1ZXN0OiBIdHRwUmVxdWVzdDxhbnk+KTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj4ge1xuICAgIHJldHVybiB0aGlzLmludGVyY2VwdG9yLmludGVyY2VwdChyZXF1ZXN0LCB0aGlzLm5leHQpO1xuICB9XG5cbn1cblxuLyoqXG4gKiBBbGxvd3MgdG8gb3ZlcnJpZGUgZGVmYXVsdCBkeW5hbWljIGludGVyY2VwdG9ycyB0aGF0IGNhbiBiZSBkaXNhYmxlZCB3aXRoIHRoZSBIdHRwU2VydmljZSBleHRlbnNpb24uXG4gKiBFeGNlcHQgZm9yIHZlcnkgc3BlY2lmaWMgbmVlZHMsIHlvdSBzaG91bGQgYmV0dGVyIGNvbmZpZ3VyZSB0aGVzZSBpbnRlcmNlcHRvcnMgZGlyZWN0bHkgaW4gdGhlIGNvbnN0cnVjdG9yIGJlbG93XG4gKiBmb3IgYmV0dGVyIHJlYWRhYmlsaXR5LlxuICpcbiAqIEZvciBzdGF0aWMgaW50ZXJjZXB0b3JzIHRoYXQgc2hvdWxkIGFsd2F5cyBiZSBlbmFibGVkIChsaWtlIEFwaVByZWZpeEludGVyY2VwdG9yKSwgdXNlIHRoZSBzdGFuZGFyZFxuICogSFRUUF9JTlRFUkNFUFRPUlMgdG9rZW4uXG4gKi9cbmV4cG9ydCBjb25zdCBIVFRQX0RZTkFNSUNfSU5URVJDRVBUT1JTID0gbmV3IEluamVjdGlvblRva2VuPEh0dHBJbnRlcmNlcHRvcj4oJ0hUVFBfRFlOQU1JQ19JTlRFUkNFUFRPUlMnKTtcblxuLyoqXG4gKiBFeHRlbmRzIEh0dHBDbGllbnQgd2l0aCBwZXIgcmVxdWVzdCBjb25maWd1cmF0aW9uIHVzaW5nIGR5bmFtaWMgaW50ZXJjZXB0b3JzLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSHR0cFNlcnZpY2UgZXh0ZW5kcyBIdHRwQ2xpZW50IHtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGh0dHBIYW5kbGVyOiBIdHRwSGFuZGxlcixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoSFRUUF9EWU5BTUlDX0lOVEVSQ0VQVE9SUykgcHJpdmF0ZSBpbnRlcmNlcHRvcnM6IEh0dHBJbnRlcmNlcHRvcltdID0gW10pIHtcbiAgICBzdXBlcihodHRwSGFuZGxlcik7XG5cbiAgICBpZiAoIXRoaXMuaW50ZXJjZXB0b3JzKSB7XG4gICAgICAvLyBDb25maWd1cmUgZGVmYXVsdCBpbnRlcmNlcHRvcnMgdGhhdCBjYW4gYmUgZGlzYWJsZWQgaGVyZVxuICAgICAgdGhpcy5pbnRlcmNlcHRvcnMgPSBbXG4gICAgICAgIHRoaXMuaW5qZWN0b3IuZ2V0KEFwaVByZWZpeEludGVyY2VwdG9yKSxcbiAgICAgICAgdGhpcy5pbmplY3Rvci5nZXQoRXJyb3JIYW5kbGVySW50ZXJjZXB0b3IpLFxuICAgICAgICB0aGlzLmluamVjdG9yLmdldChNb2NrSW50ZXJjZXB0b3IpLFxuICAgICAgICB0aGlzLmluamVjdG9yLmdldChKd3RJbnRlcmNlcHRvciksXG4gICAgICAgIHRoaXMuaW5qZWN0b3IuZ2V0KENzcmZJbnRlcmNlcHRvcilcbiAgICAgIF07XG4gICAgfVxuICB9XG5cbiAgY2FjaGUoZm9yY2VVcGRhdGU/OiBib29sZWFuKTogSHR0cFNlcnZpY2Uge1xuICAgIGNvbnN0IGNhY2hlSW50ZXJjZXB0b3IgPSB0aGlzLmluamVjdG9yLmdldChDYWNoZUludGVyY2VwdG9yKS5jb25maWd1cmUoe3VwZGF0ZTogZm9yY2VVcGRhdGV9KTtcbiAgICByZXR1cm4gdGhpcy5hZGRJbnRlcmNlcHRvcihjYWNoZUludGVyY2VwdG9yKTtcbiAgfVxuXG4gIHNraXBFcnJvckhhbmRsZXIoKTogSHR0cFNlcnZpY2Uge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUludGVyY2VwdG9yKEVycm9ySGFuZGxlckludGVyY2VwdG9yKTtcbiAgfVxuXG4gIGRpc2FibGVBcGlQcmVmaXgoKTogSHR0cFNlcnZpY2Uge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUludGVyY2VwdG9yKEFwaVByZWZpeEludGVyY2VwdG9yKTtcbiAgfVxuXG4gIGRpc2FibGVEZWZhdWx0TW9jaygpOiBIdHRwU2VydmljZSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlSW50ZXJjZXB0b3IoTW9ja0ludGVyY2VwdG9yKTtcbiAgfVxuXG4gIGFkZE1vY2sobW9ja0ludGVyY2VwdG9yOiBIdHRwSW50ZXJjZXB0b3IpOiBIdHRwU2VydmljZSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkSW50ZXJjZXB0b3IobW9ja0ludGVyY2VwdG9yKTtcbiAgfVxuXG4gIC8vIE92ZXJyaWRlIHRoZSBvcmlnaW5hbCBtZXRob2QgdG8gd2lyZSBpbnRlcmNlcHRvcnMgd2hlbiB0cmlnZ2VyaW5nIHRoZSByZXF1ZXN0LlxuICByZXF1ZXN0KG1ldGhvZD86IGFueSwgdXJsPzogYW55LCBvcHRpb25zPzogYW55KTogYW55IHtcbiAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5pbnRlcmNlcHRvcnMucmVkdWNlUmlnaHQoXG4gICAgICAobmV4dCwgaW50ZXJjZXB0b3IpID0+IG5ldyBIdHRwSW50ZXJjZXB0b3JIYW5kbGVyKG5leHQsIGludGVyY2VwdG9yKSxcbiAgICAgIHRoaXMuaHR0cEhhbmRsZXJcbiAgICApO1xuICAgIHJldHVybiBuZXcgSHR0cENsaWVudChoYW5kbGVyKS5yZXF1ZXN0KG1ldGhvZCwgdXJsLCBvcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVtb3ZlSW50ZXJjZXB0b3IoaW50ZXJjZXB0b3JUeXBlOiBGdW5jdGlvbik6IEh0dHBTZXJ2aWNlIHtcbiAgICByZXR1cm4gbmV3IEh0dHBTZXJ2aWNlKFxuICAgICAgdGhpcy5odHRwSGFuZGxlcixcbiAgICAgIHRoaXMuaW5qZWN0b3IsXG4gICAgICB0aGlzLmludGVyY2VwdG9ycy5maWx0ZXIoaSA9PiAhKGkgaW5zdGFuY2VvZiBpbnRlcmNlcHRvclR5cGUpKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGFkZEludGVyY2VwdG9yKGludGVyY2VwdG9yOiBIdHRwSW50ZXJjZXB0b3IpOiBIdHRwU2VydmljZSB7XG4gICAgcmV0dXJuIG5ldyBIdHRwU2VydmljZShcbiAgICAgIHRoaXMuaHR0cEhhbmRsZXIsXG4gICAgICB0aGlzLmluamVjdG9yLFxuICAgICAgdGhpcy5pbnRlcmNlcHRvcnMuY29uY2F0KFtpbnRlcmNlcHRvcl0pXG4gICAgKTtcbiAgfVxuXG59XG4iXX0=