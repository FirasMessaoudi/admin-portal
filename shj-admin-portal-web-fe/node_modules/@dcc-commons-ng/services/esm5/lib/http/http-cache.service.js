/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */
import { __decorate, __metadata } from "tslib";
import { Injectable } from '@angular/core';
import { each } from 'lodash';
import { Logger } from '../logging/logging.service';
var log = new Logger('HttpCacheService');
var cachePersistenceKey = 'httpCache';
/**
 * Provides a cache facility for HTTP requests with configurable persistence policy.
 */
var HttpCacheService = /** @class */ (function () {
    function HttpCacheService() {
        this.cachedData = {};
        this.storage = null;
        this.loadCacheData();
    }
    /**
     * Sets the cache data for the specified request.
     * @param {!string} url The request URL.
     * @param {ResponseOptions} data The received data.
     * @param {Date=} lastUpdated The cache last update, current date is used if not specified.
     */
    HttpCacheService.prototype.setCacheData = function (url, data, lastUpdated) {
        this.cachedData[url] = {
            lastUpdated: lastUpdated || new Date(),
            data: data
        };
        log.debug("Cache set for key: \"" + url + "\"");
        this.saveCacheData();
    };
    /**
     * Gets the cached data for the specified request.
     * @param {!string} url The request URL.
     * @return {?ResponseOptions} The cached data or null if no cached data exists for this request.
     */
    HttpCacheService.prototype.getCacheData = function (url) {
        var cacheEntry = this.cachedData[url];
        if (cacheEntry) {
            log.debug("Cache hit for key: \"" + url + "\"");
            return cacheEntry.data;
        }
        return null;
    };
    /**
     * Gets the cached entry for the specified request.
     * @param {!string} url The request URL.
     * @return {?HttpCacheEntry} The cache entry or null if no cache entry exists for this request.
     */
    HttpCacheService.prototype.getHttpCacheEntry = function (url) {
        return this.cachedData[url] || null;
    };
    /**
     * Clears the cached entry (if exists) for the specified request.
     * @param {!string} url The request URL.
     */
    HttpCacheService.prototype.clearCache = function (url) {
        delete this.cachedData[url];
        log.debug("Cache cleared for key: \"" + url + "\"");
        this.saveCacheData();
    };
    /**
     * Cleans cache entries older than the specified date.
     * @param {date=} expirationDate The cache expiration date. If no date is specified, all cache is cleared.
     */
    HttpCacheService.prototype.cleanCache = function (expirationDate) {
        var _this = this;
        if (expirationDate) {
            each(this.cachedData, function (value, key) {
                if (expirationDate >= value.lastUpdated) {
                    delete _this.cachedData[key];
                }
            });
        }
        else {
            this.cachedData = {};
        }
        this.saveCacheData();
    };
    /**
     * Sets the cache persistence policy.
     * Note that changing the cache persistence will also clear the cache from its previous storage.
     * @param {'local'|'session'=} persistence How the cache should be persisted, it can be either local or session
     *   storage, or if no value is provided it will be only in-memory (default).
     */
    HttpCacheService.prototype.setPersistence = function (persistence) {
        this.cleanCache();
        this.storage = persistence === 'local' || persistence === 'session' ? window[persistence + 'Storage'] : null;
        this.loadCacheData();
    };
    HttpCacheService.prototype.saveCacheData = function () {
        if (this.storage) {
            this.storage[cachePersistenceKey] = JSON.stringify(this.cachedData);
        }
    };
    HttpCacheService.prototype.loadCacheData = function () {
        var data = this.storage ? this.storage[cachePersistenceKey] : null;
        this.cachedData = data ? JSON.parse(data) : {};
    };
    HttpCacheService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [])
    ], HttpCacheService);
    return HttpCacheService;
}());
export { HttpCacheService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHR0cC1jYWNoZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGRjYy1jb21tb25zLW5nL3NlcnZpY2VzLyIsInNvdXJjZXMiOlsibGliL2h0dHAvaHR0cC1jYWNoZS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztHQUVHOztBQUVILE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFekMsT0FBTyxFQUFDLElBQUksRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUU1QixPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sNEJBQTRCLENBQUM7QUFFbEQsSUFBTSxHQUFHLEdBQUcsSUFBSSxNQUFNLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUMzQyxJQUFNLG1CQUFtQixHQUFHLFdBQVcsQ0FBQztBQU94Qzs7R0FFRztBQUVIO0lBS0U7UUFIUSxlQUFVLEdBQXVDLEVBQUUsQ0FBQztRQUNwRCxZQUFPLEdBQW1CLElBQUksQ0FBQztRQUdyQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsdUNBQVksR0FBWixVQUFhLEdBQVcsRUFBRSxJQUF1QixFQUFFLFdBQWtCO1FBQ25FLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUc7WUFDckIsV0FBVyxFQUFFLFdBQVcsSUFBSSxJQUFJLElBQUksRUFBRTtZQUN0QyxJQUFJLEVBQUUsSUFBSTtTQUNYLENBQUM7UUFDRixHQUFHLENBQUMsS0FBSyxDQUFDLDBCQUF1QixHQUFHLE9BQUcsQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILHVDQUFZLEdBQVosVUFBYSxHQUFXO1FBQ3RCLElBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFeEMsSUFBSSxVQUFVLEVBQUU7WUFDZCxHQUFHLENBQUMsS0FBSyxDQUFDLDBCQUF1QixHQUFHLE9BQUcsQ0FBQyxDQUFDO1lBQ3pDLE9BQU8sVUFBVSxDQUFDLElBQUksQ0FBQztTQUN4QjtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCw0Q0FBaUIsR0FBakIsVUFBa0IsR0FBVztRQUMzQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDO0lBQ3RDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxxQ0FBVSxHQUFWLFVBQVcsR0FBVztRQUNwQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDNUIsR0FBRyxDQUFDLEtBQUssQ0FBQyw4QkFBMkIsR0FBRyxPQUFHLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7T0FHRztJQUNILHFDQUFVLEdBQVYsVUFBVyxjQUFxQjtRQUFoQyxpQkFXQztRQVZDLElBQUksY0FBYyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLFVBQUMsS0FBcUIsRUFBRSxHQUFXO2dCQUN2RCxJQUFJLGNBQWMsSUFBSSxLQUFLLENBQUMsV0FBVyxFQUFFO29CQUN2QyxPQUFPLEtBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQzdCO1lBQ0gsQ0FBQyxDQUFDLENBQUM7U0FDSjthQUFNO1lBQ0wsSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUM7U0FDdEI7UUFDRCxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gseUNBQWMsR0FBZCxVQUFlLFdBQWlDO1FBQzlDLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUNsQixJQUFJLENBQUMsT0FBTyxHQUFHLFdBQVcsS0FBSyxPQUFPLElBQUksV0FBVyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFdBQVcsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQzdHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN2QixDQUFDO0lBRU8sd0NBQWEsR0FBckI7UUFDRSxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDaEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ3JFO0lBQ0gsQ0FBQztJQUVPLHdDQUFhLEdBQXJCO1FBQ0UsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFDckUsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUNqRCxDQUFDO0lBakdVLGdCQUFnQjtRQUQ1QixVQUFVLEVBQUU7O09BQ0EsZ0JBQWdCLENBbUc1QjtJQUFELHVCQUFDO0NBQUEsQUFuR0QsSUFtR0M7U0FuR1ksZ0JBQWdCIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBFTE0uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7SHR0cFJlc3BvbnNlfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQge2VhY2h9IGZyb20gJ2xvZGFzaCc7XG5cbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi9sb2dnaW5nL2xvZ2dpbmcuc2VydmljZSc7XG5cbmNvbnN0IGxvZyA9IG5ldyBMb2dnZXIoJ0h0dHBDYWNoZVNlcnZpY2UnKTtcbmNvbnN0IGNhY2hlUGVyc2lzdGVuY2VLZXkgPSAnaHR0cENhY2hlJztcblxuZXhwb3J0IGludGVyZmFjZSBIdHRwQ2FjaGVFbnRyeSB7XG4gIGxhc3RVcGRhdGVkOiBEYXRlO1xuICBkYXRhOiBIdHRwUmVzcG9uc2U8YW55Pjtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBhIGNhY2hlIGZhY2lsaXR5IGZvciBIVFRQIHJlcXVlc3RzIHdpdGggY29uZmlndXJhYmxlIHBlcnNpc3RlbmNlIHBvbGljeS5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEh0dHBDYWNoZVNlcnZpY2Uge1xuXG4gIHByaXZhdGUgY2FjaGVkRGF0YTogeyBba2V5OiBzdHJpbmddOiBIdHRwQ2FjaGVFbnRyeTsgfSA9IHt9O1xuICBwcml2YXRlIHN0b3JhZ2U6IFN0b3JhZ2UgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmxvYWRDYWNoZURhdGEoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjYWNoZSBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gdXJsIFRoZSByZXF1ZXN0IFVSTC5cbiAgICogQHBhcmFtIHtSZXNwb25zZU9wdGlvbnN9IGRhdGEgVGhlIHJlY2VpdmVkIGRhdGEuXG4gICAqIEBwYXJhbSB7RGF0ZT19IGxhc3RVcGRhdGVkIFRoZSBjYWNoZSBsYXN0IHVwZGF0ZSwgY3VycmVudCBkYXRlIGlzIHVzZWQgaWYgbm90IHNwZWNpZmllZC5cbiAgICovXG4gIHNldENhY2hlRGF0YSh1cmw6IHN0cmluZywgZGF0YTogSHR0cFJlc3BvbnNlPGFueT4sIGxhc3RVcGRhdGVkPzogRGF0ZSkge1xuICAgIHRoaXMuY2FjaGVkRGF0YVt1cmxdID0ge1xuICAgICAgbGFzdFVwZGF0ZWQ6IGxhc3RVcGRhdGVkIHx8IG5ldyBEYXRlKCksXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfTtcbiAgICBsb2cuZGVidWcoYENhY2hlIHNldCBmb3Iga2V5OiBcIiR7dXJsfVwiYCk7XG4gICAgdGhpcy5zYXZlQ2FjaGVEYXRhKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY2FjaGVkIGRhdGEgZm9yIHRoZSBzcGVjaWZpZWQgcmVxdWVzdC5cbiAgICogQHBhcmFtIHshc3RyaW5nfSB1cmwgVGhlIHJlcXVlc3QgVVJMLlxuICAgKiBAcmV0dXJuIHs/UmVzcG9uc2VPcHRpb25zfSBUaGUgY2FjaGVkIGRhdGEgb3IgbnVsbCBpZiBubyBjYWNoZWQgZGF0YSBleGlzdHMgZm9yIHRoaXMgcmVxdWVzdC5cbiAgICovXG4gIGdldENhY2hlRGF0YSh1cmw6IHN0cmluZyk6IEh0dHBSZXNwb25zZTxhbnk+IHwgbnVsbCB7XG4gICAgY29uc3QgY2FjaGVFbnRyeSA9IHRoaXMuY2FjaGVkRGF0YVt1cmxdO1xuXG4gICAgaWYgKGNhY2hlRW50cnkpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgQ2FjaGUgaGl0IGZvciBrZXk6IFwiJHt1cmx9XCJgKTtcbiAgICAgIHJldHVybiBjYWNoZUVudHJ5LmRhdGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY2FjaGVkIGVudHJ5IGZvciB0aGUgc3BlY2lmaWVkIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gdXJsIFRoZSByZXF1ZXN0IFVSTC5cbiAgICogQHJldHVybiB7P0h0dHBDYWNoZUVudHJ5fSBUaGUgY2FjaGUgZW50cnkgb3IgbnVsbCBpZiBubyBjYWNoZSBlbnRyeSBleGlzdHMgZm9yIHRoaXMgcmVxdWVzdC5cbiAgICovXG4gIGdldEh0dHBDYWNoZUVudHJ5KHVybDogc3RyaW5nKTogSHR0cENhY2hlRW50cnkgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZWREYXRhW3VybF0gfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGNhY2hlZCBlbnRyeSAoaWYgZXhpc3RzKSBmb3IgdGhlIHNwZWNpZmllZCByZXF1ZXN0LlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IHVybCBUaGUgcmVxdWVzdCBVUkwuXG4gICAqL1xuICBjbGVhckNhY2hlKHVybDogc3RyaW5nKTogdm9pZCB7XG4gICAgZGVsZXRlIHRoaXMuY2FjaGVkRGF0YVt1cmxdO1xuICAgIGxvZy5kZWJ1ZyhgQ2FjaGUgY2xlYXJlZCBmb3Iga2V5OiBcIiR7dXJsfVwiYCk7XG4gICAgdGhpcy5zYXZlQ2FjaGVEYXRhKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW5zIGNhY2hlIGVudHJpZXMgb2xkZXIgdGhhbiB0aGUgc3BlY2lmaWVkIGRhdGUuXG4gICAqIEBwYXJhbSB7ZGF0ZT19IGV4cGlyYXRpb25EYXRlIFRoZSBjYWNoZSBleHBpcmF0aW9uIGRhdGUuIElmIG5vIGRhdGUgaXMgc3BlY2lmaWVkLCBhbGwgY2FjaGUgaXMgY2xlYXJlZC5cbiAgICovXG4gIGNsZWFuQ2FjaGUoZXhwaXJhdGlvbkRhdGU/OiBEYXRlKSB7XG4gICAgaWYgKGV4cGlyYXRpb25EYXRlKSB7XG4gICAgICBlYWNoKHRoaXMuY2FjaGVkRGF0YSwgKHZhbHVlOiBIdHRwQ2FjaGVFbnRyeSwga2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKGV4cGlyYXRpb25EYXRlID49IHZhbHVlLmxhc3RVcGRhdGVkKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuY2FjaGVkRGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYWNoZWREYXRhID0ge307XG4gICAgfVxuICAgIHRoaXMuc2F2ZUNhY2hlRGF0YSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNhY2hlIHBlcnNpc3RlbmNlIHBvbGljeS5cbiAgICogTm90ZSB0aGF0IGNoYW5naW5nIHRoZSBjYWNoZSBwZXJzaXN0ZW5jZSB3aWxsIGFsc28gY2xlYXIgdGhlIGNhY2hlIGZyb20gaXRzIHByZXZpb3VzIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7J2xvY2FsJ3wnc2Vzc2lvbic9fSBwZXJzaXN0ZW5jZSBIb3cgdGhlIGNhY2hlIHNob3VsZCBiZSBwZXJzaXN0ZWQsIGl0IGNhbiBiZSBlaXRoZXIgbG9jYWwgb3Igc2Vzc2lvblxuICAgKiAgIHN0b3JhZ2UsIG9yIGlmIG5vIHZhbHVlIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgb25seSBpbi1tZW1vcnkgKGRlZmF1bHQpLlxuICAgKi9cbiAgc2V0UGVyc2lzdGVuY2UocGVyc2lzdGVuY2U/OiAnbG9jYWwnIHwgJ3Nlc3Npb24nKSB7XG4gICAgdGhpcy5jbGVhbkNhY2hlKCk7XG4gICAgdGhpcy5zdG9yYWdlID0gcGVyc2lzdGVuY2UgPT09ICdsb2NhbCcgfHwgcGVyc2lzdGVuY2UgPT09ICdzZXNzaW9uJyA/IHdpbmRvd1twZXJzaXN0ZW5jZSArICdTdG9yYWdlJ10gOiBudWxsO1xuICAgIHRoaXMubG9hZENhY2hlRGF0YSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBzYXZlQ2FjaGVEYXRhKCkge1xuICAgIGlmICh0aGlzLnN0b3JhZ2UpIHtcbiAgICAgIHRoaXMuc3RvcmFnZVtjYWNoZVBlcnNpc3RlbmNlS2V5XSA9IEpTT04uc3RyaW5naWZ5KHRoaXMuY2FjaGVkRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBsb2FkQ2FjaGVEYXRhKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnN0b3JhZ2UgPyB0aGlzLnN0b3JhZ2VbY2FjaGVQZXJzaXN0ZW5jZUtleV0gOiBudWxsO1xuICAgIHRoaXMuY2FjaGVkRGF0YSA9IGRhdGEgPyBKU09OLnBhcnNlKGRhdGEpIDoge307XG4gIH1cblxufVxuIl19