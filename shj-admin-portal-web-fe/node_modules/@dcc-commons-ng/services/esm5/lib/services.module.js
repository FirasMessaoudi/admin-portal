/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */
import { __decorate, __metadata, __param } from "tslib";
import { NgModule, Optional, SkipSelf } from '@angular/core';
import { CommonModule } from '@angular/common';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { RouteReuseStrategy, RouterModule } from '@angular/router';
import { TranslateLoader, TranslateModule } from '@ngx-translate/core';
import { RouteReusableStrategy } from './route/route-reusable-strategy';
import { I18nService } from './i18n/i18n.service';
import { HttpService } from './http/http.service';
import { HttpCacheService } from './http/http-cache.service';
import { ApiPrefixInterceptor } from './http/api-prefix.interceptor';
import { ErrorHandlerInterceptor } from './http/error-handler.interceptor';
import { CacheInterceptor } from './http/cache.interceptor';
import { JwtInterceptor, LOGIN_URL, PUBLIC_URL_PATTERNS } from './http/jwt.interceptor';
import { TranslateHttpLoader } from "@ngx-translate/http-loader";
import { CookieService } from "ngx-cookie-service";
import { CsrfInterceptor } from "./http/csrf.interceptor";
import { MockInterceptor } from "./http/mock.interceptor";
export var I18N_FOLDER_PATH = './assets/i18n/';
var ɵ0 = (HttpLoaderFactory);
var DccCommonsNgServicesModule = /** @class */ (function () {
    function DccCommonsNgServicesModule(parentModule) {
        // Import guard
        if (parentModule) {
            throw new Error(parentModule + " has already been loaded. Import Services module in the AppModule only.");
        }
    }
    DccCommonsNgServicesModule_1 = DccCommonsNgServicesModule;
    DccCommonsNgServicesModule.forRoot = function (publicUrlPatterns, loginUrl, i18nFolderPath) {
        if (publicUrlPatterns === void 0) { publicUrlPatterns = []; }
        return {
            ngModule: DccCommonsNgServicesModule_1,
            providers: [
                { provide: PUBLIC_URL_PATTERNS, useValue: publicUrlPatterns },
                { provide: LOGIN_URL, useValue: loginUrl },
                { provide: I18N_FOLDER_PATH, useValue: i18nFolderPath }
            ]
        };
    };
    var DccCommonsNgServicesModule_1;
    DccCommonsNgServicesModule.ctorParameters = function () { return [
        { type: DccCommonsNgServicesModule, decorators: [{ type: Optional }, { type: SkipSelf }] }
    ]; };
    __decorate([
        __param(0, Optional()), __param(1, Optional()), __param(2, Optional()),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Array, String, String]),
        __metadata("design:returntype", Object)
    ], DccCommonsNgServicesModule, "forRoot", null);
    DccCommonsNgServicesModule = DccCommonsNgServicesModule_1 = __decorate([
        NgModule({
            imports: [
                CommonModule,
                HttpClientModule,
                TranslateModule.forRoot({
                    loader: {
                        provide: TranslateLoader,
                        useFactory: ɵ0,
                        deps: [HttpClient, I18N_FOLDER_PATH]
                    }
                }),
                RouterModule
            ],
            declarations: [],
            providers: [
                I18nService,
                HttpCacheService,
                ApiPrefixInterceptor,
                ErrorHandlerInterceptor,
                CacheInterceptor,
                CookieService,
                JwtInterceptor,
                CsrfInterceptor,
                MockInterceptor,
                {
                    provide: HttpClient,
                    useClass: HttpService
                },
                {
                    provide: RouteReuseStrategy,
                    useClass: RouteReusableStrategy
                }
            ]
        }),
        __param(0, Optional()), __param(0, SkipSelf()),
        __metadata("design:paramtypes", [DccCommonsNgServicesModule])
    ], DccCommonsNgServicesModule);
    return DccCommonsNgServicesModule;
}());
export { DccCommonsNgServicesModule };
export function HttpLoaderFactory(http, i18nFolderPath) {
    return new TranslateHttpLoader(http, i18nFolderPath, '.json');
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmljZXMubW9kdWxlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGRjYy1jb21tb25zLW5nL3NlcnZpY2VzLyIsInNvdXJjZXMiOlsibGliL3NlcnZpY2VzLm1vZHVsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7R0FFRzs7QUFFSCxPQUFPLEVBQXNCLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ2hGLE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUM3QyxPQUFPLEVBQUMsVUFBVSxFQUFFLGdCQUFnQixFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFDbEUsT0FBTyxFQUFDLGtCQUFrQixFQUFFLFlBQVksRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQ2pFLE9BQU8sRUFBQyxlQUFlLEVBQUUsZUFBZSxFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFFckUsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0saUNBQWlDLENBQUM7QUFDdEUsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBQ2hELE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUNoRCxPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUMzRCxPQUFPLEVBQUMsb0JBQW9CLEVBQUMsTUFBTSwrQkFBK0IsQ0FBQztBQUNuRSxPQUFPLEVBQUMsdUJBQXVCLEVBQUMsTUFBTSxrQ0FBa0MsQ0FBQztBQUN6RSxPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUMxRCxPQUFPLEVBQUMsY0FBYyxFQUFFLFNBQVMsRUFBRSxtQkFBbUIsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBQ3RGLE9BQU8sRUFBQyxtQkFBbUIsRUFBQyxNQUFNLDRCQUE0QixDQUFDO0FBQy9ELE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUNqRCxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFDeEQsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLHlCQUF5QixDQUFDO0FBRXhELE1BQU0sQ0FBQyxJQUFNLGdCQUFnQixHQUFXLGdCQUFnQixDQUFDO1NBVXJDLENBQUMsaUJBQWlCLENBQUM7QUEyQnZDO0lBQ0Usb0NBQW9DLFlBQXdDO1FBQzFFLGVBQWU7UUFDZixJQUFJLFlBQVksRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFJLFlBQVksNEVBQXlFLENBQUMsQ0FBQztTQUMzRztJQUNILENBQUM7bUNBTlUsMEJBQTBCO0lBUTlCLGtDQUFPLEdBQWQsVUFBMkIsaUJBQXFDLEVBQWMsUUFBZ0IsRUFBYyxjQUFzQjtRQUF2RyxrQ0FBQSxFQUFBLHNCQUFxQztRQUM5RCxPQUFPO1lBQ0wsUUFBUSxFQUFFLDRCQUEwQjtZQUNwQyxTQUFTLEVBQUU7Z0JBQ1QsRUFBQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsUUFBUSxFQUFFLGlCQUFpQixFQUFDO2dCQUMzRCxFQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBQztnQkFDeEMsRUFBQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBQzthQUN0RDtTQUNGLENBQUE7SUFDSCxDQUFDOzs7Z0JBaEJpRCwwQkFBMEIsdUJBQS9ELFFBQVEsWUFBSSxRQUFROztJQU9qQztRQUFnQixXQUFBLFFBQVEsRUFBRSxDQUFBLEVBQXlDLFdBQUEsUUFBUSxFQUFFLENBQUEsRUFBb0IsV0FBQSxRQUFRLEVBQUUsQ0FBQTs7eUNBQTdELEtBQUs7O21EQVNsRDtJQWpCVSwwQkFBMEI7UUFsQ3RDLFFBQVEsQ0FBQztZQUNSLE9BQU8sRUFBRTtnQkFDUCxZQUFZO2dCQUNaLGdCQUFnQjtnQkFDaEIsZUFBZSxDQUFDLE9BQU8sQ0FBQztvQkFDdEIsTUFBTSxFQUFFO3dCQUNOLE9BQU8sRUFBRSxlQUFlO3dCQUN4QixVQUFVLElBQXFCO3dCQUMvQixJQUFJLEVBQUUsQ0FBQyxVQUFVLEVBQUUsZ0JBQWdCLENBQUM7cUJBQ3JDO2lCQUNGLENBQUM7Z0JBQ0YsWUFBWTthQUNiO1lBQ0QsWUFBWSxFQUFFLEVBQUU7WUFDaEIsU0FBUyxFQUFFO2dCQUNULFdBQVc7Z0JBQ1gsZ0JBQWdCO2dCQUNoQixvQkFBb0I7Z0JBQ3BCLHVCQUF1QjtnQkFDdkIsZ0JBQWdCO2dCQUNoQixhQUFhO2dCQUNiLGNBQWM7Z0JBQ2QsZUFBZTtnQkFDZixlQUFlO2dCQUNmO29CQUNFLE9BQU8sRUFBRSxVQUFVO29CQUNuQixRQUFRLEVBQUUsV0FBVztpQkFDdEI7Z0JBQ0Q7b0JBQ0UsT0FBTyxFQUFFLGtCQUFrQjtvQkFDM0IsUUFBUSxFQUFFLHFCQUFxQjtpQkFDaEM7YUFDRjtTQUNGLENBQUM7UUFFYSxXQUFBLFFBQVEsRUFBRSxDQUFBLEVBQUUsV0FBQSxRQUFRLEVBQUUsQ0FBQTt5Q0FBZSwwQkFBMEI7T0FEakUsMEJBQTBCLENBbUJ0QztJQUFELGlDQUFDO0NBQUEsQUFuQkQsSUFtQkM7U0FuQlksMEJBQTBCO0FBcUJ2QyxNQUFNLFVBQVUsaUJBQWlCLENBQUMsSUFBZ0IsRUFBRSxjQUFzQjtJQUN4RSxPQUFPLElBQUksbUJBQW1CLENBQUMsSUFBSSxFQUFFLGNBQWMsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUNoRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxOSBFTE0uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuaW1wb3J0IHtNb2R1bGVXaXRoUHJvdmlkZXJzLCBOZ01vZHVsZSwgT3B0aW9uYWwsIFNraXBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtIdHRwQ2xpZW50LCBIdHRwQ2xpZW50TW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQge1JvdXRlUmV1c2VTdHJhdGVneSwgUm91dGVyTW9kdWxlfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHtUcmFuc2xhdGVMb2FkZXIsIFRyYW5zbGF0ZU1vZHVsZX0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XG5cbmltcG9ydCB7Um91dGVSZXVzYWJsZVN0cmF0ZWd5fSBmcm9tICcuL3JvdXRlL3JvdXRlLXJldXNhYmxlLXN0cmF0ZWd5JztcbmltcG9ydCB7STE4blNlcnZpY2V9IGZyb20gJy4vaTE4bi9pMThuLnNlcnZpY2UnO1xuaW1wb3J0IHtIdHRwU2VydmljZX0gZnJvbSAnLi9odHRwL2h0dHAuc2VydmljZSc7XG5pbXBvcnQge0h0dHBDYWNoZVNlcnZpY2V9IGZyb20gJy4vaHR0cC9odHRwLWNhY2hlLnNlcnZpY2UnO1xuaW1wb3J0IHtBcGlQcmVmaXhJbnRlcmNlcHRvcn0gZnJvbSAnLi9odHRwL2FwaS1wcmVmaXguaW50ZXJjZXB0b3InO1xuaW1wb3J0IHtFcnJvckhhbmRsZXJJbnRlcmNlcHRvcn0gZnJvbSAnLi9odHRwL2Vycm9yLWhhbmRsZXIuaW50ZXJjZXB0b3InO1xuaW1wb3J0IHtDYWNoZUludGVyY2VwdG9yfSBmcm9tICcuL2h0dHAvY2FjaGUuaW50ZXJjZXB0b3InO1xuaW1wb3J0IHtKd3RJbnRlcmNlcHRvciwgTE9HSU5fVVJMLCBQVUJMSUNfVVJMX1BBVFRFUk5TfSBmcm9tICcuL2h0dHAvand0LmludGVyY2VwdG9yJztcbmltcG9ydCB7VHJhbnNsYXRlSHR0cExvYWRlcn0gZnJvbSBcIkBuZ3gtdHJhbnNsYXRlL2h0dHAtbG9hZGVyXCI7XG5pbXBvcnQge0Nvb2tpZVNlcnZpY2V9IGZyb20gXCJuZ3gtY29va2llLXNlcnZpY2VcIjtcbmltcG9ydCB7Q3NyZkludGVyY2VwdG9yfSBmcm9tIFwiLi9odHRwL2NzcmYuaW50ZXJjZXB0b3JcIjtcbmltcG9ydCB7TW9ja0ludGVyY2VwdG9yfSBmcm9tIFwiLi9odHRwL21vY2suaW50ZXJjZXB0b3JcIjtcblxuZXhwb3J0IGNvbnN0IEkxOE5fRk9MREVSX1BBVEg6IHN0cmluZyA9ICcuL2Fzc2V0cy9pMThuLyc7XG5cblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBIdHRwQ2xpZW50TW9kdWxlLFxuICAgIFRyYW5zbGF0ZU1vZHVsZS5mb3JSb290KHtcbiAgICAgIGxvYWRlcjoge1xuICAgICAgICBwcm92aWRlOiBUcmFuc2xhdGVMb2FkZXIsXG4gICAgICAgIHVzZUZhY3Rvcnk6IChIdHRwTG9hZGVyRmFjdG9yeSksXG4gICAgICAgIGRlcHM6IFtIdHRwQ2xpZW50LCBJMThOX0ZPTERFUl9QQVRIXVxuICAgICAgfVxuICAgIH0pLFxuICAgIFJvdXRlck1vZHVsZVxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtdLFxuICBwcm92aWRlcnM6IFtcbiAgICBJMThuU2VydmljZSxcbiAgICBIdHRwQ2FjaGVTZXJ2aWNlLFxuICAgIEFwaVByZWZpeEludGVyY2VwdG9yLFxuICAgIEVycm9ySGFuZGxlckludGVyY2VwdG9yLFxuICAgIENhY2hlSW50ZXJjZXB0b3IsXG4gICAgQ29va2llU2VydmljZSxcbiAgICBKd3RJbnRlcmNlcHRvcixcbiAgICBDc3JmSW50ZXJjZXB0b3IsXG4gICAgTW9ja0ludGVyY2VwdG9yLFxuICAgIHtcbiAgICAgIHByb3ZpZGU6IEh0dHBDbGllbnQsXG4gICAgICB1c2VDbGFzczogSHR0cFNlcnZpY2VcbiAgICB9LFxuICAgIHtcbiAgICAgIHByb3ZpZGU6IFJvdXRlUmV1c2VTdHJhdGVneSxcbiAgICAgIHVzZUNsYXNzOiBSb3V0ZVJldXNhYmxlU3RyYXRlZ3lcbiAgICB9XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgRGNjQ29tbW9uc05nU2VydmljZXNNb2R1bGUge1xuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBAU2tpcFNlbGYoKSBwYXJlbnRNb2R1bGU6IERjY0NvbW1vbnNOZ1NlcnZpY2VzTW9kdWxlKSB7XG4gICAgLy8gSW1wb3J0IGd1YXJkXG4gICAgaWYgKHBhcmVudE1vZHVsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3BhcmVudE1vZHVsZX0gaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQuIEltcG9ydCBTZXJ2aWNlcyBtb2R1bGUgaW4gdGhlIEFwcE1vZHVsZSBvbmx5LmApO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBmb3JSb290KEBPcHRpb25hbCgpIHB1YmxpY1VybFBhdHRlcm5zOiBBcnJheTxzdHJpbmc+ID0gW10sIEBPcHRpb25hbCgpIGxvZ2luVXJsOiBzdHJpbmcsIEBPcHRpb25hbCgpIGkxOG5Gb2xkZXJQYXRoOiBzdHJpbmcpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmdNb2R1bGU6IERjY0NvbW1vbnNOZ1NlcnZpY2VzTW9kdWxlLFxuICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtwcm92aWRlOiBQVUJMSUNfVVJMX1BBVFRFUk5TLCB1c2VWYWx1ZTogcHVibGljVXJsUGF0dGVybnN9LFxuICAgICAgICB7cHJvdmlkZTogTE9HSU5fVVJMLCB1c2VWYWx1ZTogbG9naW5Vcmx9LFxuICAgICAgICB7cHJvdmlkZTogSTE4Tl9GT0xERVJfUEFUSCwgdXNlVmFsdWU6IGkxOG5Gb2xkZXJQYXRofVxuICAgICAgXVxuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIdHRwTG9hZGVyRmFjdG9yeShodHRwOiBIdHRwQ2xpZW50LCBpMThuRm9sZGVyUGF0aDogc3RyaW5nKSB7XG4gIHJldHVybiBuZXcgVHJhbnNsYXRlSHR0cExvYWRlcihodHRwLCBpMThuRm9sZGVyUGF0aCwgJy5qc29uJyk7XG59XG4iXX0=