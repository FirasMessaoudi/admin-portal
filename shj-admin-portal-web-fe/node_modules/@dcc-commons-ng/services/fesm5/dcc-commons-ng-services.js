import { __extends, __decorate, __metadata, __param, __values } from 'tslib';
import { Injectable, Inject, Optional, InjectionToken, Injector, SkipSelf, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { HttpErrorResponse, HttpResponse, HttpXsrfTokenExtractor, HttpClient, HttpHandler, HttpClientModule } from '@angular/common/http';
import { RouteReuseStrategy, Router, RouterModule } from '@angular/router';
import { TranslateService, TranslateModule, TranslateLoader } from '@ngx-translate/core';
import { includes, each } from 'lodash';
import { catchError, map, mergeMap, materialize, delay, dematerialize } from 'rxjs/operators';
import { Observable, timer, of } from 'rxjs';
import { CookieService } from 'ngx-cookie-service';
import { TranslateHttpLoader } from '@ngx-translate/http-loader';
import { trigger, transition, query, style, sequence, animateChild, group, animate } from '@angular/animations';

/**
 * A route strategy allowing for explicit route reuse.
 * Used as a workaround for https://github.com/angular/angular/issues/18374
 * To reuse a given route, add `data: { reuse: true }` to the route definition.
 */
var RouteReusableStrategy = /** @class */ (function (_super) {
    __extends(RouteReusableStrategy, _super);
    function RouteReusableStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RouteReusableStrategy.prototype.shouldDetach = function (route) {
        return false;
    };
    RouteReusableStrategy.prototype.store = function (route, detachedTree) {
    };
    RouteReusableStrategy.prototype.shouldAttach = function (route) {
        return false;
    };
    RouteReusableStrategy.prototype.retrieve = function (route) {
        return null;
    };
    RouteReusableStrategy.prototype.shouldReuseRoute = function (future, curr) {
        return (future.routeConfig === curr.routeConfig) || future.data.reuse;
    };
    return RouteReusableStrategy;
}(RouteReuseStrategy));

/**
 * Simple logger system with the possibility of registering custom outputs.
 *
 * 4 different log levels are provided, with corresponding methods:
 * - debug   : for debug information
 * - info    : for informative status of the application (success, ...)
 * - warning : for non-critical errors that do not prevent normal application behavior
 * - error   : for critical errors that prevent normal application behavior
 *
 * Example usage:
 * ```
 * import { Logger } from 'app/core/logger.service';
 *
 * const log = new Logger('myFile');
 * ...
 * log.debug('something happened');
 * ```
 *
 * To disable debug and info logs in production, add this snippet to your root component:
 * ```
 * export class AppComponent implements OnInit {
 *   ngOnInit() {
 *     if (environment.production) {
 *       Logger.enableProductionMode();
 *     }
 *     ...
 *   }
 * }
 *
 * If you want to process logs through other outputs than console, you can add LogOutput functions to Logger.outputs.
 */
/**
 * The possible log levels.
 * LogLevel.Off is never emitted and only used with Logger.level property to disable logs.
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Off"] = 0] = "Off";
    LogLevel[LogLevel["Error"] = 1] = "Error";
    LogLevel[LogLevel["Warning"] = 2] = "Warning";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Debug"] = 4] = "Debug";
})(LogLevel || (LogLevel = {}));
var Logger = /** @class */ (function () {
    function Logger(source) {
        this.source = source;
    }
    /**
     * Enables production mode.
     * Sets logging level to LogLevel.Warning.
     */
    Logger.enableProductionMode = function () {
        Logger.level = LogLevel.Warning;
    };
    /**
     * Logs messages or objects  with the debug level.
     * Works the same as console.log().
     */
    Logger.prototype.debug = function () {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            objects[_i] = arguments[_i];
        }
        this.log(console.log, LogLevel.Debug, objects);
    };
    /**
     * Logs messages or objects  with the info level.
     * Works the same as console.log().
     */
    Logger.prototype.info = function () {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            objects[_i] = arguments[_i];
        }
        this.log(console.info, LogLevel.Info, objects);
    };
    /**
     * Logs messages or objects  with the warning level.
     * Works the same as console.log().
     */
    Logger.prototype.warn = function () {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            objects[_i] = arguments[_i];
        }
        this.log(console.warn, LogLevel.Warning, objects);
    };
    /**
     * Logs messages or objects  with the error level.
     * Works the same as console.log().
     */
    Logger.prototype.error = function () {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            objects[_i] = arguments[_i];
        }
        this.log(console.error, LogLevel.Error, objects);
    };
    Logger.prototype.log = function (func, level, objects) {
        var _this = this;
        if (level <= Logger.level) {
            var log = this.source ? ['[' + this.source + ']'].concat(objects) : objects;
            func.apply(console, log);
            Logger.outputs.forEach(function (output) { return output.apply(output, [_this.source, level].concat(objects)); });
        }
    };
    /**
     * Current logging level.
     * Set it to LogLevel.Off to disable logs completely.
     */
    Logger.level = LogLevel.Debug;
    /**
     * Additional log outputs.
     */
    Logger.outputs = [];
    return Logger;
}());

var log = new Logger('I18nService');
var languageKey = 'language';
/**
 * Pass-through function to mark a string for translation extraction.
 * Running `npm translations:extract` will include the given string by using this.
 * @param {string} s The string to extract for translation.
 * @return {string} The same string.
 */
function extract(s) {
    return s;
}
var I18nService = /** @class */ (function () {
    function I18nService(translateService) {
        this.translateService = translateService;
        this.defaultLanguage = "en-US";
    }
    Object.defineProperty(I18nService.prototype, "language", {
        /**
         * Gets the current language.
         * @return {string} The current language code.
         */
        get: function () {
            return this.translateService.currentLang;
        },
        /**
         * Sets the current language.
         * Note: The current language is saved to the local storage.
         * If no parameter is specified, the language is loaded from local storage (if present).
         * @param {string} language The IETF language code to set.
         */
        set: function (language) {
            language = language || localStorage.getItem(languageKey) || this.translateService.getBrowserCultureLang();
            var isSupportedLanguage = includes(this.supportedLanguages, language);
            // If no exact match is found, search without the region
            if (language && !isSupportedLanguage) {
                language = language.split('-')[0];
                language = this.supportedLanguages.find(function (supportedLanguage) { return supportedLanguage.startsWith(language); }) || '';
                isSupportedLanguage = Boolean(language);
            }
            // Fallback if language is not supported
            if (!isSupportedLanguage) {
                if (this.translateService.getBrowserLang() !== undefined) {
                    language = this.translateService.getBrowserLang();
                }
                else {
                    language = this.defaultLanguage;
                }
            }
            log.debug("Language set to " + language);
            this.translateService.use(language);
            if (language && language.startsWith('ar')) {
                document.querySelector("html").setAttribute('dir', 'rtl');
                document.querySelector("html").setAttribute('lang', language);
            }
            else {
                document.querySelector("html").setAttribute('dir', 'ltr');
                document.querySelector("html").setAttribute('lang', language);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initializes i18n for the application.
     * Loads language from local storage if present, or sets default language.
     * @param {!string} defaultLanguage The default language to use.
     * @param {Array.<String>} supportedLanguages The list of supported languages.
     */
    I18nService.prototype.init = function (defaultLanguage, supportedLanguages) {
        this.defaultLanguage = defaultLanguage;
        this.supportedLanguages = supportedLanguages;
        this.language = '';
        this.translateService.onLangChange
            .subscribe(function (event) {
            localStorage.setItem(languageKey, event.lang);
        });
    };
    I18nService.ctorParameters = function () { return [
        { type: TranslateService }
    ]; };
    I18nService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [TranslateService])
    ], I18nService);
    return I18nService;
}());

var log$1 = new Logger('ErrorHandlerInterceptor');
/**
 * Adds a default error handler to all requests.
 */
var ErrorHandlerInterceptor = /** @class */ (function () {
    function ErrorHandlerInterceptor(router, environment) {
        this.router = router;
        this.environment = environment;
    }
    ErrorHandlerInterceptor.prototype.intercept = function (request, next) {
        var _this = this;
        return next.handle(request).pipe(catchError(function (error) { return _this.errorHandler(error); }));
    };
    // Customize the default error handler here if needed
    ErrorHandlerInterceptor.prototype.errorHandler = function (response) {
        if (!this.environment.production) {
            // Do something with the error
            log$1.error('Request error', JSON.stringify(response));
        }
        if (response instanceof HttpErrorResponse) {
            if (response.status === 401) {
                this.router.navigate(['login.html']);
            }
        }
        throw response;
    };
    ErrorHandlerInterceptor.ctorParameters = function () { return [
        { type: Router },
        { type: undefined, decorators: [{ type: Inject, args: ['environment',] }] }
    ]; };
    ErrorHandlerInterceptor = __decorate([
        Injectable(),
        __param(1, Inject('environment')),
        __metadata("design:paramtypes", [Router, Object])
    ], ErrorHandlerInterceptor);
    return ErrorHandlerInterceptor;
}());

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */
var log$2 = new Logger('HttpCacheService');
var cachePersistenceKey = 'httpCache';
/**
 * Provides a cache facility for HTTP requests with configurable persistence policy.
 */
var HttpCacheService = /** @class */ (function () {
    function HttpCacheService() {
        this.cachedData = {};
        this.storage = null;
        this.loadCacheData();
    }
    /**
     * Sets the cache data for the specified request.
     * @param {!string} url The request URL.
     * @param {ResponseOptions} data The received data.
     * @param {Date=} lastUpdated The cache last update, current date is used if not specified.
     */
    HttpCacheService.prototype.setCacheData = function (url, data, lastUpdated) {
        this.cachedData[url] = {
            lastUpdated: lastUpdated || new Date(),
            data: data
        };
        log$2.debug("Cache set for key: \"" + url + "\"");
        this.saveCacheData();
    };
    /**
     * Gets the cached data for the specified request.
     * @param {!string} url The request URL.
     * @return {?ResponseOptions} The cached data or null if no cached data exists for this request.
     */
    HttpCacheService.prototype.getCacheData = function (url) {
        var cacheEntry = this.cachedData[url];
        if (cacheEntry) {
            log$2.debug("Cache hit for key: \"" + url + "\"");
            return cacheEntry.data;
        }
        return null;
    };
    /**
     * Gets the cached entry for the specified request.
     * @param {!string} url The request URL.
     * @return {?HttpCacheEntry} The cache entry or null if no cache entry exists for this request.
     */
    HttpCacheService.prototype.getHttpCacheEntry = function (url) {
        return this.cachedData[url] || null;
    };
    /**
     * Clears the cached entry (if exists) for the specified request.
     * @param {!string} url The request URL.
     */
    HttpCacheService.prototype.clearCache = function (url) {
        delete this.cachedData[url];
        log$2.debug("Cache cleared for key: \"" + url + "\"");
        this.saveCacheData();
    };
    /**
     * Cleans cache entries older than the specified date.
     * @param {date=} expirationDate The cache expiration date. If no date is specified, all cache is cleared.
     */
    HttpCacheService.prototype.cleanCache = function (expirationDate) {
        var _this = this;
        if (expirationDate) {
            each(this.cachedData, function (value, key) {
                if (expirationDate >= value.lastUpdated) {
                    delete _this.cachedData[key];
                }
            });
        }
        else {
            this.cachedData = {};
        }
        this.saveCacheData();
    };
    /**
     * Sets the cache persistence policy.
     * Note that changing the cache persistence will also clear the cache from its previous storage.
     * @param {'local'|'session'=} persistence How the cache should be persisted, it can be either local or session
     *   storage, or if no value is provided it will be only in-memory (default).
     */
    HttpCacheService.prototype.setPersistence = function (persistence) {
        this.cleanCache();
        this.storage = persistence === 'local' || persistence === 'session' ? window[persistence + 'Storage'] : null;
        this.loadCacheData();
    };
    HttpCacheService.prototype.saveCacheData = function () {
        if (this.storage) {
            this.storage[cachePersistenceKey] = JSON.stringify(this.cachedData);
        }
    };
    HttpCacheService.prototype.loadCacheData = function () {
        var data = this.storage ? this.storage[cachePersistenceKey] : null;
        this.cachedData = data ? JSON.parse(data) : {};
    };
    HttpCacheService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [])
    ], HttpCacheService);
    return HttpCacheService;
}());

/**
 * Caches HTTP requests.
 * Use ExtendedHttpClient fluent API to configure caching for each request.
 */
var CacheInterceptor = /** @class */ (function () {
    function CacheInterceptor(httpCacheService) {
        this.httpCacheService = httpCacheService;
        this.forceUpdate = false;
    }
    CacheInterceptor_1 = CacheInterceptor;
    /**
     * Configures interceptor options
     * @param {{update: boolean}} options If update option is enabled, forces request to be made and updates cache entry.
     * @return {CacheInterceptor} The configured instance.
     */
    CacheInterceptor.prototype.configure = function (options) {
        var instance = new CacheInterceptor_1(this.httpCacheService);
        if (options && options.update) {
            instance.forceUpdate = true;
        }
        return instance;
    };
    CacheInterceptor.prototype.intercept = function (request, next) {
        var _this = this;
        if (request.method !== 'GET') {
            return next.handle(request);
        }
        return new Observable(function (subscriber) {
            var cachedData = _this.forceUpdate ? null : _this.httpCacheService.getCacheData(request.urlWithParams);
            if (cachedData !== null) {
                // Create new response to avoid side-effects
                subscriber.next(new HttpResponse(cachedData));
                subscriber.complete();
            }
            else {
                next.handle(request)
                    .subscribe(function (event) {
                    if (event instanceof HttpResponse) {
                        _this.httpCacheService.setCacheData(request.urlWithParams, event);
                    }
                    subscriber.next(event);
                }, function (error) { return subscriber.error(error); }, function () { return subscriber.complete(); });
            }
        });
    };
    var CacheInterceptor_1;
    CacheInterceptor.ctorParameters = function () { return [
        { type: HttpCacheService }
    ]; };
    CacheInterceptor = CacheInterceptor_1 = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [HttpCacheService])
    ], CacheInterceptor);
    return CacheInterceptor;
}());

/**
 * Prefixes all requests with `environment.backendMappings`.
 */
var ApiPrefixInterceptor = /** @class */ (function () {
    function ApiPrefixInterceptor(environment) {
        this.environment = environment;
    }
    ApiPrefixInterceptor.prototype.intercept = function (request, next) {
        var e_1, _a;
        if (this.environment.production || !this.environment.dev) {
            var backendUrlMappings = this.environment.backendMappings;
            var requestUrl = void 0, serverUrl = void 0;
            try {
                for (var backendUrlMappings_1 = __values(backendUrlMappings), backendUrlMappings_1_1 = backendUrlMappings_1.next(); !backendUrlMappings_1_1.done; backendUrlMappings_1_1 = backendUrlMappings_1.next()) {
                    var urlMapping = backendUrlMappings_1_1.value;
                    if (request.url.startsWith(urlMapping.mapping)) {
                        serverUrl = urlMapping.url;
                        if (serverUrl.endsWith('/')) {
                            serverUrl = serverUrl.substring(0, serverUrl.length - 1);
                        }
                        requestUrl = request.url.replace(urlMapping.mapping, serverUrl);
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (backendUrlMappings_1_1 && !backendUrlMappings_1_1.done && (_a = backendUrlMappings_1.return)) _a.call(backendUrlMappings_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            request = request.clone({ url: requestUrl });
        }
        return next.handle(request);
    };
    ApiPrefixInterceptor.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: ['environment',] }] }
    ]; };
    ApiPrefixInterceptor = __decorate([
        Injectable(),
        __param(0, Inject('environment')),
        __metadata("design:paramtypes", [Object])
    ], ApiPrefixInterceptor);
    return ApiPrefixInterceptor;
}());

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */
var TOKEN_EXPIRY_COOKIE_NAME = 'X-SEC-TK-EXP';
var TOKEN_COOKIE_NAME = 'X-SEC-TK';
var CONTENT_TYPE_HEADER_NAME = 'Content-Type';
var USER_STORAGE_ITEM_KEY = 'currentUser';
var log$3 = new Logger('Login');
var PUBLIC_URL_PATTERNS = 'PUBLIC_URL_PATTERNS';
var LOGIN_URL = 'LOGIN_URL';
var JwtInterceptor = /** @class */ (function () {
    function JwtInterceptor(cookieService, router, environment, publicUrlPatterns, loginUrl) {
        if (publicUrlPatterns === void 0) { publicUrlPatterns = []; }
        if (loginUrl === void 0) { loginUrl = '/login.html'; }
        this.cookieService = cookieService;
        this.router = router;
        this.environment = environment;
        this.publicUrlPatterns = publicUrlPatterns;
        this.loginUrl = loginUrl;
        this.tokenExpiryDateTimerSubscription = null;
    }
    JwtInterceptor.prototype.intercept = function (request, next) {
        var _this = this;
        var headers = request.headers;
        if (request.headers.get(CONTENT_TYPE_HEADER_NAME) == null) {
            headers = request.headers.append(CONTENT_TYPE_HEADER_NAME, 'application/json');
        }
        else if (request.headers.get(CONTENT_TYPE_HEADER_NAME).startsWith("multipart/form-data")) {
            headers = request.headers.delete(CONTENT_TYPE_HEADER_NAME);
        }
        var currentUser = JSON.parse(localStorage.getItem(USER_STORAGE_ITEM_KEY));
        if (currentUser && this.tokenExpiryDateTimerSubscription == null) {
            this.refreshTokenTimer();
        }
        request = request.clone({ headers: headers });
        var started = Date.now();
        return next.handle(request).pipe(map(function (event) {
            if (event instanceof HttpResponse) {
                if (!_this.environment.production) {
                    var elapsed = Date.now() - started;
                    console.log("Request for " + request.urlWithParams + " took " + elapsed + " ms.");
                }
                if (_this.cookieService.get(TOKEN_EXPIRY_COOKIE_NAME)) {
                    console.log("found " + TOKEN_EXPIRY_COOKIE_NAME + " with value [" + _this.cookieService.get(TOKEN_EXPIRY_COOKIE_NAME) + "]");
                    if (_this.tokenExpiryDateTimerSubscription) {
                        _this.tokenExpiryDateTimerSubscription.unsubscribe();
                        _this.refreshTokenTimer();
                    }
                }
            }
            return event;
        }));
    };
    JwtInterceptor.prototype.refreshTokenTimer = function () {
        var _this = this;
        var isPublicUrl = false;
        this.publicUrlPatterns.forEach(function (urlPattern) {
            isPublicUrl = isPublicUrl || _this.router.url.startsWith(urlPattern);
        });
        if (isPublicUrl && !this.router.url.startsWith(this.loginUrl)) {
            // do nothing
            log$3.debug('skipping public url...');
            return;
        }
        log$3.debug('secured url, setting timer...');
        var tokenExpiry = this.cookieService.get(TOKEN_EXPIRY_COOKIE_NAME);
        this.tokenExpiryDateTimerSubscription = timer(tokenExpiry).subscribe(function () {
            localStorage.removeItem(USER_STORAGE_ITEM_KEY);
            _this.cookieService.delete(TOKEN_EXPIRY_COOKIE_NAME);
            _this.cookieService.delete(TOKEN_COOKIE_NAME);
            _this.router.navigate([_this.loginUrl], { replaceUrl: true });
        });
    };
    JwtInterceptor.ctorParameters = function () { return [
        { type: CookieService },
        { type: Router },
        { type: undefined, decorators: [{ type: Inject, args: ['environment',] }] },
        { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [PUBLIC_URL_PATTERNS,] }] },
        { type: String, decorators: [{ type: Optional }, { type: Inject, args: [LOGIN_URL,] }] }
    ]; };
    JwtInterceptor = __decorate([
        Injectable(),
        __param(2, Inject('environment')),
        __param(3, Optional()), __param(3, Inject(PUBLIC_URL_PATTERNS)),
        __param(4, Optional()), __param(4, Inject(LOGIN_URL)),
        __metadata("design:paramtypes", [CookieService, Router, Object, Array, String])
    ], JwtInterceptor);
    return JwtInterceptor;
}());

var CSRF_HEADER_NAME = 'X-XSRF-TOKEN';
var CsrfInterceptor = /** @class */ (function () {
    function CsrfInterceptor(cookieService, router, tokenExtractor) {
        this.cookieService = cookieService;
        this.router = router;
        this.tokenExtractor = tokenExtractor;
    }
    CsrfInterceptor.prototype.intercept = function (request, next) {
        var token = this.tokenExtractor.getToken();
        // add authorization header with jwt token if available
        var headers = request.headers;
        if (token != null && request.headers.get(CSRF_HEADER_NAME) == null && request.method == 'POST') {
            headers = request.headers.append(CSRF_HEADER_NAME, token);
        }
        request = request.clone({ headers: headers });
        return next.handle(request);
    };
    CsrfInterceptor.ctorParameters = function () { return [
        { type: CookieService },
        { type: Router },
        { type: HttpXsrfTokenExtractor }
    ]; };
    CsrfInterceptor = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [CookieService, Router, HttpXsrfTokenExtractor])
    ], CsrfInterceptor);
    return CsrfInterceptor;
}());

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */
var log$4 = new Logger('MockInterceptor');
var MockInterceptor = /** @class */ (function () {
    function MockInterceptor(environment) {
        this.environment = environment;
    }
    MockInterceptor.prototype.intercept = function (request, next) {
        // if mock is not enabled or we are not in dev environment, then do nothing
        if (!this.environment.mock || !this.environment.dev) {
            return next.handle(request);
        }
        log$4.debug('################## Mock is enabled');
        // array in local storage for registered users
        var users = JSON.parse(localStorage.getItem('users')) || [];
        // wrap in delayed observable to simulate server api call
        return of(null).pipe(mergeMap(function () {
            // authenticate
            if (request.url.indexOf('/api/auth/login') != -1 && request.method === 'POST') {
                // if login details are valid return 200 OK with user details and fake jwt token
                var body = {
                    authorities: [{ "authority": "DQS_ADMIN" }],
                    principal: "admin",
                    name: "admin"
                };
                return of(new HttpResponse({ status: 200, body: body }));
            }
            // logout
            if (request.url.indexOf('/api/auth/logout') != -1 && request.method === 'POST') {
                // if login details are valid return 200 OK with user details and fake jwt token
                return of(new HttpResponse({ status: 200, body: 'true' }));
            }
            // get users
            if (request.url.indexOf('/api/users/list') != -1 && request.method === 'GET') {
                // check for fake auth token in header and return users if valid, this security is implemented server side in a real application
                users = JSON.parse('{"content":[{"id":21,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444444,"userName":"qweqwe","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251767000,"authorities":[{"id":21,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":22,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444445,"userName":"qweqwer","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251787000,"authorities":[{"id":22,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":23,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444446,"userName":"qweqwerq","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251908000,"authorities":[{"id":23,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":24,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444447,"userName":"qweqwerw","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251909000,"authorities":[{"id":24,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":25,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444448,"userName":"qweqwere","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251909000,"authorities":[{"id":25,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":26,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444449,"userName":"qweqwerr","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251909000,"authorities":[{"id":26,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":27,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444450,"userName":"qweqwert","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251909000,"authorities":[{"id":27,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":28,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444452,"userName":"qweqweru","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251910000,"authorities":[{"id":28,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":29,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444451,"userName":"qweqwery","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251910000,"authorities":[{"id":29,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":30,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444454,"userName":"qweqwero","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251910000,"authorities":[{"id":30,"authority":"DQS_USER"}],"tokenExpiryDate":null}],"pageable":{"sort":{"sorted":false,"unsorted":true,"empty":true},"pageNumber":2,"pageSize":10,"offset":20,"unpaged":false,"paged":true},"last":false,"totalPages":8,"totalElements":71,"sort":{"sorted":false,"unsorted":true,"empty":true},"first":false,"numberOfElements":10,"size":10,"number":2,"empty":false}');
                return of(new HttpResponse({ status: 200, body: users }));
            }
            // get user details
            if (request.url.indexOf('/api/users/find') != -1 && request.method === 'GET') {
                // check for fake auth token in header and return users if valid, this security is implemented server side in a real application
                var body = JSON.parse('{"id":22,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444445,"userName":"qweqwer","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251787000,"authorities":[{"id":22,"authority":"DQS_USER"}],"tokenExpiryDate":null}');
                return of(new HttpResponse({ status: 200, body: body }));
            }
            // pass through any requests not handled above
            return next.handle(request);
        }))
            // call materialize and dematerialize to ensure delay even if an error is thrown (https://github.com/Reactive-Extensions/RxJS/issues/648)
            .pipe(materialize())
            .pipe(delay(500))
            .pipe(dematerialize());
    };
    MockInterceptor.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: ['environment',] }] }
    ]; };
    MockInterceptor = __decorate([
        Injectable(),
        __param(0, Inject('environment')),
        __metadata("design:paramtypes", [Object])
    ], MockInterceptor);
    return MockInterceptor;
}());

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */
// From @angular/common/http/src/interceptor: allows to chain interceptors
var HttpInterceptorHandler = /** @class */ (function () {
    function HttpInterceptorHandler(next, interceptor) {
        this.next = next;
        this.interceptor = interceptor;
    }
    HttpInterceptorHandler.prototype.handle = function (request) {
        return this.interceptor.intercept(request, this.next);
    };
    return HttpInterceptorHandler;
}());
/**
 * Allows to override default dynamic interceptors that can be disabled with the HttpService extension.
 * Except for very specific needs, you should better configure these interceptors directly in the constructor below
 * for better readability.
 *
 * For static interceptors that should always be enabled (like ApiPrefixInterceptor), use the standard
 * HTTP_INTERCEPTORS token.
 */
var HTTP_DYNAMIC_INTERCEPTORS = new InjectionToken('HTTP_DYNAMIC_INTERCEPTORS');
/**
 * Extends HttpClient with per request configuration using dynamic interceptors.
 */
var HttpService = /** @class */ (function (_super) {
    __extends(HttpService, _super);
    function HttpService(httpHandler, injector, interceptors) {
        if (interceptors === void 0) { interceptors = []; }
        var _this = _super.call(this, httpHandler) || this;
        _this.httpHandler = httpHandler;
        _this.injector = injector;
        _this.interceptors = interceptors;
        if (!_this.interceptors) {
            // Configure default interceptors that can be disabled here
            _this.interceptors = [
                _this.injector.get(ApiPrefixInterceptor),
                _this.injector.get(ErrorHandlerInterceptor),
                _this.injector.get(MockInterceptor),
                _this.injector.get(JwtInterceptor),
                _this.injector.get(CsrfInterceptor)
            ];
        }
        return _this;
    }
    HttpService_1 = HttpService;
    HttpService.prototype.cache = function (forceUpdate) {
        var cacheInterceptor = this.injector.get(CacheInterceptor).configure({ update: forceUpdate });
        return this.addInterceptor(cacheInterceptor);
    };
    HttpService.prototype.skipErrorHandler = function () {
        return this.removeInterceptor(ErrorHandlerInterceptor);
    };
    HttpService.prototype.disableApiPrefix = function () {
        return this.removeInterceptor(ApiPrefixInterceptor);
    };
    HttpService.prototype.disableDefaultMock = function () {
        return this.removeInterceptor(MockInterceptor);
    };
    HttpService.prototype.addMock = function (mockInterceptor) {
        return this.addInterceptor(mockInterceptor);
    };
    // Override the original method to wire interceptors when triggering the request.
    HttpService.prototype.request = function (method, url, options) {
        var handler = this.interceptors.reduceRight(function (next, interceptor) { return new HttpInterceptorHandler(next, interceptor); }, this.httpHandler);
        return new HttpClient(handler).request(method, url, options);
    };
    HttpService.prototype.removeInterceptor = function (interceptorType) {
        return new HttpService_1(this.httpHandler, this.injector, this.interceptors.filter(function (i) { return !(i instanceof interceptorType); }));
    };
    HttpService.prototype.addInterceptor = function (interceptor) {
        return new HttpService_1(this.httpHandler, this.injector, this.interceptors.concat([interceptor]));
    };
    var HttpService_1;
    HttpService.ctorParameters = function () { return [
        { type: HttpHandler },
        { type: Injector },
        { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [HTTP_DYNAMIC_INTERCEPTORS,] }] }
    ]; };
    HttpService = HttpService_1 = __decorate([
        Injectable(),
        __param(2, Optional()), __param(2, Inject(HTTP_DYNAMIC_INTERCEPTORS)),
        __metadata("design:paramtypes", [HttpHandler,
            Injector, Array])
    ], HttpService);
    return HttpService;
}(HttpClient));

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */
var I18N_FOLDER_PATH = './assets/i18n/';
var ɵ0 = (HttpLoaderFactory);
var DccCommonsNgServicesModule = /** @class */ (function () {
    function DccCommonsNgServicesModule(parentModule) {
        // Import guard
        if (parentModule) {
            throw new Error(parentModule + " has already been loaded. Import Services module in the AppModule only.");
        }
    }
    DccCommonsNgServicesModule_1 = DccCommonsNgServicesModule;
    DccCommonsNgServicesModule.forRoot = function (publicUrlPatterns, loginUrl, i18nFolderPath) {
        if (publicUrlPatterns === void 0) { publicUrlPatterns = []; }
        return {
            ngModule: DccCommonsNgServicesModule_1,
            providers: [
                { provide: PUBLIC_URL_PATTERNS, useValue: publicUrlPatterns },
                { provide: LOGIN_URL, useValue: loginUrl },
                { provide: I18N_FOLDER_PATH, useValue: i18nFolderPath }
            ]
        };
    };
    var DccCommonsNgServicesModule_1;
    DccCommonsNgServicesModule.ctorParameters = function () { return [
        { type: DccCommonsNgServicesModule, decorators: [{ type: Optional }, { type: SkipSelf }] }
    ]; };
    __decorate([
        __param(0, Optional()), __param(1, Optional()), __param(2, Optional()),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Array, String, String]),
        __metadata("design:returntype", Object)
    ], DccCommonsNgServicesModule, "forRoot", null);
    DccCommonsNgServicesModule = DccCommonsNgServicesModule_1 = __decorate([
        NgModule({
            imports: [
                CommonModule,
                HttpClientModule,
                TranslateModule.forRoot({
                    loader: {
                        provide: TranslateLoader,
                        useFactory: ɵ0,
                        deps: [HttpClient, I18N_FOLDER_PATH]
                    }
                }),
                RouterModule
            ],
            declarations: [],
            providers: [
                I18nService,
                HttpCacheService,
                ApiPrefixInterceptor,
                ErrorHandlerInterceptor,
                CacheInterceptor,
                CookieService,
                JwtInterceptor,
                CsrfInterceptor,
                MockInterceptor,
                {
                    provide: HttpClient,
                    useClass: HttpService
                },
                {
                    provide: RouteReuseStrategy,
                    useClass: RouteReusableStrategy
                }
            ]
        }),
        __param(0, Optional()), __param(0, SkipSelf()),
        __metadata("design:paramtypes", [DccCommonsNgServicesModule])
    ], DccCommonsNgServicesModule);
    return DccCommonsNgServicesModule;
}());
function HttpLoaderFactory(http, i18nFolderPath) {
    return new TranslateHttpLoader(http, i18nFolderPath, '.json');
}

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */
var RouteAnimations = trigger('routerAnimations', [
    transition('* <=> *', [
        // css styles at start of transition
        //style({ opacity: 0 }),
        // animation and styles at end of transition
        //animate('0.5s', style({ opacity: 1 }))
        query(':enter, :leave', style({ position: 'fixed', width: '100%' }), { optional: true }),
        query(':enter', style({ transform: 'translateX(100%)' }), { optional: true }),
        sequence([
            query(':leave', animateChild(), { optional: true }),
            group([
                query(':leave', [
                    style({ transform: 'translateX(0%)' }),
                    animate('500ms cubic-bezier(.75,-0.48,.26,1.52)', style({ transform: 'translateX(-100%)' }))
                ], { optional: true }),
                query(':enter', [
                    style({ transform: 'translateX(100%)' }),
                    animate('500ms cubic-bezier(.75,-0.48,.26,1.52)', style({ transform: 'translateX(0%)' }))
                ], { optional: true }),
            ]),
            query(':enter', animateChild(), { optional: true }),
        ])
    ])
]);
/**
 * Provides helper methods to create routes.
 */
var Route = /** @class */ (function () {
    function Route() {
    }
    /**
     * Creates routes using the shell component and authentication.
     * @param routes The routes to add.
     * @return {Route} The new route using shell as the base.
     */
    Route.withShell = function (routes, appLayout, authGuard) {
        return {
            path: '',
            component: appLayout,
            children: routes,
            canActivate: [authGuard],
            // Reuse ShellComponent instance when navigating between child views
            data: { reuse: true }
        };
    };
    return Route;
}());

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */

/*
 * Public API Surface of services
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ApiPrefixInterceptor, CacheInterceptor, CsrfInterceptor, DccCommonsNgServicesModule, ErrorHandlerInterceptor, HTTP_DYNAMIC_INTERCEPTORS, HttpCacheService, HttpLoaderFactory, HttpService, I18N_FOLDER_PATH, I18nService, JwtInterceptor, LOGIN_URL, LogLevel, Logger, MockInterceptor, PUBLIC_URL_PATTERNS, Route, RouteAnimations, RouteReusableStrategy, extract, ɵ0, I18nService as ɵa, HttpCacheService as ɵb, ApiPrefixInterceptor as ɵc, ErrorHandlerInterceptor as ɵd, CacheInterceptor as ɵe, PUBLIC_URL_PATTERNS as ɵf, LOGIN_URL as ɵg, JwtInterceptor as ɵh, CsrfInterceptor as ɵi, MockInterceptor as ɵj, HTTP_DYNAMIC_INTERCEPTORS as ɵk, HttpService as ɵl, RouteReusableStrategy as ɵm };
//# sourceMappingURL=dcc-commons-ng-services.js.map
