import { __decorate, __metadata, __param } from 'tslib';
import { Injectable, Inject, Optional, InjectionToken, Injector, SkipSelf, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { HttpErrorResponse, HttpResponse, HttpXsrfTokenExtractor, HttpClient, HttpHandler, HttpClientModule } from '@angular/common/http';
import { RouteReuseStrategy, Router, RouterModule } from '@angular/router';
import { TranslateService, TranslateModule, TranslateLoader } from '@ngx-translate/core';
import { includes, each } from 'lodash';
import { catchError, map, mergeMap, materialize, delay, dematerialize } from 'rxjs/operators';
import { Observable, timer, of } from 'rxjs';
import { CookieService } from 'ngx-cookie-service';
import { TranslateHttpLoader } from '@ngx-translate/http-loader';
import { trigger, transition, query, style, sequence, animateChild, group, animate } from '@angular/animations';

/**
 * A route strategy allowing for explicit route reuse.
 * Used as a workaround for https://github.com/angular/angular/issues/18374
 * To reuse a given route, add `data: { reuse: true }` to the route definition.
 */
class RouteReusableStrategy extends RouteReuseStrategy {
    shouldDetach(route) {
        return false;
    }
    store(route, detachedTree) {
    }
    shouldAttach(route) {
        return false;
    }
    retrieve(route) {
        return null;
    }
    shouldReuseRoute(future, curr) {
        return (future.routeConfig === curr.routeConfig) || future.data.reuse;
    }
}

/**
 * Simple logger system with the possibility of registering custom outputs.
 *
 * 4 different log levels are provided, with corresponding methods:
 * - debug   : for debug information
 * - info    : for informative status of the application (success, ...)
 * - warning : for non-critical errors that do not prevent normal application behavior
 * - error   : for critical errors that prevent normal application behavior
 *
 * Example usage:
 * ```
 * import { Logger } from 'app/core/logger.service';
 *
 * const log = new Logger('myFile');
 * ...
 * log.debug('something happened');
 * ```
 *
 * To disable debug and info logs in production, add this snippet to your root component:
 * ```
 * export class AppComponent implements OnInit {
 *   ngOnInit() {
 *     if (environment.production) {
 *       Logger.enableProductionMode();
 *     }
 *     ...
 *   }
 * }
 *
 * If you want to process logs through other outputs than console, you can add LogOutput functions to Logger.outputs.
 */
/**
 * The possible log levels.
 * LogLevel.Off is never emitted and only used with Logger.level property to disable logs.
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Off"] = 0] = "Off";
    LogLevel[LogLevel["Error"] = 1] = "Error";
    LogLevel[LogLevel["Warning"] = 2] = "Warning";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Debug"] = 4] = "Debug";
})(LogLevel || (LogLevel = {}));
class Logger {
    constructor(source) {
        this.source = source;
    }
    /**
     * Enables production mode.
     * Sets logging level to LogLevel.Warning.
     */
    static enableProductionMode() {
        Logger.level = LogLevel.Warning;
    }
    /**
     * Logs messages or objects  with the debug level.
     * Works the same as console.log().
     */
    debug(...objects) {
        this.log(console.log, LogLevel.Debug, objects);
    }
    /**
     * Logs messages or objects  with the info level.
     * Works the same as console.log().
     */
    info(...objects) {
        this.log(console.info, LogLevel.Info, objects);
    }
    /**
     * Logs messages or objects  with the warning level.
     * Works the same as console.log().
     */
    warn(...objects) {
        this.log(console.warn, LogLevel.Warning, objects);
    }
    /**
     * Logs messages or objects  with the error level.
     * Works the same as console.log().
     */
    error(...objects) {
        this.log(console.error, LogLevel.Error, objects);
    }
    log(func, level, objects) {
        if (level <= Logger.level) {
            const log = this.source ? ['[' + this.source + ']'].concat(objects) : objects;
            func.apply(console, log);
            Logger.outputs.forEach((output) => output.apply(output, [this.source, level].concat(objects)));
        }
    }
}
/**
 * Current logging level.
 * Set it to LogLevel.Off to disable logs completely.
 */
Logger.level = LogLevel.Debug;
/**
 * Additional log outputs.
 */
Logger.outputs = [];

const log = new Logger('I18nService');
const languageKey = 'language';
/**
 * Pass-through function to mark a string for translation extraction.
 * Running `npm translations:extract` will include the given string by using this.
 * @param {string} s The string to extract for translation.
 * @return {string} The same string.
 */
function extract(s) {
    return s;
}
let I18nService = class I18nService {
    constructor(translateService) {
        this.translateService = translateService;
        this.defaultLanguage = "en-US";
    }
    /**
     * Gets the current language.
     * @return {string} The current language code.
     */
    get language() {
        return this.translateService.currentLang;
    }
    /**
     * Sets the current language.
     * Note: The current language is saved to the local storage.
     * If no parameter is specified, the language is loaded from local storage (if present).
     * @param {string} language The IETF language code to set.
     */
    set language(language) {
        language = language || localStorage.getItem(languageKey) || this.translateService.getBrowserCultureLang();
        let isSupportedLanguage = includes(this.supportedLanguages, language);
        // If no exact match is found, search without the region
        if (language && !isSupportedLanguage) {
            language = language.split('-')[0];
            language = this.supportedLanguages.find(supportedLanguage => supportedLanguage.startsWith(language)) || '';
            isSupportedLanguage = Boolean(language);
        }
        // Fallback if language is not supported
        if (!isSupportedLanguage) {
            if (this.translateService.getBrowserLang() !== undefined) {
                language = this.translateService.getBrowserLang();
            }
            else {
                language = this.defaultLanguage;
            }
        }
        log.debug(`Language set to ${language}`);
        this.translateService.use(language);
        if (language && language.startsWith('ar')) {
            document.querySelector("html").setAttribute('dir', 'rtl');
            document.querySelector("html").setAttribute('lang', language);
        }
        else {
            document.querySelector("html").setAttribute('dir', 'ltr');
            document.querySelector("html").setAttribute('lang', language);
        }
    }
    /**
     * Initializes i18n for the application.
     * Loads language from local storage if present, or sets default language.
     * @param {!string} defaultLanguage The default language to use.
     * @param {Array.<String>} supportedLanguages The list of supported languages.
     */
    init(defaultLanguage, supportedLanguages) {
        this.defaultLanguage = defaultLanguage;
        this.supportedLanguages = supportedLanguages;
        this.language = '';
        this.translateService.onLangChange
            .subscribe((event) => {
            localStorage.setItem(languageKey, event.lang);
        });
    }
};
I18nService.ctorParameters = () => [
    { type: TranslateService }
];
I18nService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [TranslateService])
], I18nService);

const log$1 = new Logger('ErrorHandlerInterceptor');
/**
 * Adds a default error handler to all requests.
 */
let ErrorHandlerInterceptor = class ErrorHandlerInterceptor {
    constructor(router, environment) {
        this.router = router;
        this.environment = environment;
    }
    intercept(request, next) {
        return next.handle(request).pipe(catchError(error => this.errorHandler(error)));
    }
    // Customize the default error handler here if needed
    errorHandler(response) {
        if (!this.environment.production) {
            // Do something with the error
            log$1.error('Request error', JSON.stringify(response));
        }
        if (response instanceof HttpErrorResponse) {
            if (response.status === 401) {
                this.router.navigate(['login.html']);
            }
        }
        throw response;
    }
};
ErrorHandlerInterceptor.ctorParameters = () => [
    { type: Router },
    { type: undefined, decorators: [{ type: Inject, args: ['environment',] }] }
];
ErrorHandlerInterceptor = __decorate([
    Injectable(),
    __param(1, Inject('environment')),
    __metadata("design:paramtypes", [Router, Object])
], ErrorHandlerInterceptor);

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */
const log$2 = new Logger('HttpCacheService');
const cachePersistenceKey = 'httpCache';
/**
 * Provides a cache facility for HTTP requests with configurable persistence policy.
 */
let HttpCacheService = class HttpCacheService {
    constructor() {
        this.cachedData = {};
        this.storage = null;
        this.loadCacheData();
    }
    /**
     * Sets the cache data for the specified request.
     * @param {!string} url The request URL.
     * @param {ResponseOptions} data The received data.
     * @param {Date=} lastUpdated The cache last update, current date is used if not specified.
     */
    setCacheData(url, data, lastUpdated) {
        this.cachedData[url] = {
            lastUpdated: lastUpdated || new Date(),
            data: data
        };
        log$2.debug(`Cache set for key: "${url}"`);
        this.saveCacheData();
    }
    /**
     * Gets the cached data for the specified request.
     * @param {!string} url The request URL.
     * @return {?ResponseOptions} The cached data or null if no cached data exists for this request.
     */
    getCacheData(url) {
        const cacheEntry = this.cachedData[url];
        if (cacheEntry) {
            log$2.debug(`Cache hit for key: "${url}"`);
            return cacheEntry.data;
        }
        return null;
    }
    /**
     * Gets the cached entry for the specified request.
     * @param {!string} url The request URL.
     * @return {?HttpCacheEntry} The cache entry or null if no cache entry exists for this request.
     */
    getHttpCacheEntry(url) {
        return this.cachedData[url] || null;
    }
    /**
     * Clears the cached entry (if exists) for the specified request.
     * @param {!string} url The request URL.
     */
    clearCache(url) {
        delete this.cachedData[url];
        log$2.debug(`Cache cleared for key: "${url}"`);
        this.saveCacheData();
    }
    /**
     * Cleans cache entries older than the specified date.
     * @param {date=} expirationDate The cache expiration date. If no date is specified, all cache is cleared.
     */
    cleanCache(expirationDate) {
        if (expirationDate) {
            each(this.cachedData, (value, key) => {
                if (expirationDate >= value.lastUpdated) {
                    delete this.cachedData[key];
                }
            });
        }
        else {
            this.cachedData = {};
        }
        this.saveCacheData();
    }
    /**
     * Sets the cache persistence policy.
     * Note that changing the cache persistence will also clear the cache from its previous storage.
     * @param {'local'|'session'=} persistence How the cache should be persisted, it can be either local or session
     *   storage, or if no value is provided it will be only in-memory (default).
     */
    setPersistence(persistence) {
        this.cleanCache();
        this.storage = persistence === 'local' || persistence === 'session' ? window[persistence + 'Storage'] : null;
        this.loadCacheData();
    }
    saveCacheData() {
        if (this.storage) {
            this.storage[cachePersistenceKey] = JSON.stringify(this.cachedData);
        }
    }
    loadCacheData() {
        const data = this.storage ? this.storage[cachePersistenceKey] : null;
        this.cachedData = data ? JSON.parse(data) : {};
    }
};
HttpCacheService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [])
], HttpCacheService);

var CacheInterceptor_1;
/**
 * Caches HTTP requests.
 * Use ExtendedHttpClient fluent API to configure caching for each request.
 */
let CacheInterceptor = CacheInterceptor_1 = class CacheInterceptor {
    constructor(httpCacheService) {
        this.httpCacheService = httpCacheService;
        this.forceUpdate = false;
    }
    /**
     * Configures interceptor options
     * @param {{update: boolean}} options If update option is enabled, forces request to be made and updates cache entry.
     * @return {CacheInterceptor} The configured instance.
     */
    configure(options) {
        const instance = new CacheInterceptor_1(this.httpCacheService);
        if (options && options.update) {
            instance.forceUpdate = true;
        }
        return instance;
    }
    intercept(request, next) {
        if (request.method !== 'GET') {
            return next.handle(request);
        }
        return new Observable((subscriber) => {
            const cachedData = this.forceUpdate ? null : this.httpCacheService.getCacheData(request.urlWithParams);
            if (cachedData !== null) {
                // Create new response to avoid side-effects
                subscriber.next(new HttpResponse(cachedData));
                subscriber.complete();
            }
            else {
                next.handle(request)
                    .subscribe(event => {
                    if (event instanceof HttpResponse) {
                        this.httpCacheService.setCacheData(request.urlWithParams, event);
                    }
                    subscriber.next(event);
                }, error => subscriber.error(error), () => subscriber.complete());
            }
        });
    }
};
CacheInterceptor.ctorParameters = () => [
    { type: HttpCacheService }
];
CacheInterceptor = CacheInterceptor_1 = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [HttpCacheService])
], CacheInterceptor);

/**
 * Prefixes all requests with `environment.backendMappings`.
 */
let ApiPrefixInterceptor = class ApiPrefixInterceptor {
    constructor(environment) {
        this.environment = environment;
    }
    intercept(request, next) {
        if (this.environment.production || !this.environment.dev) {
            let backendUrlMappings = this.environment.backendMappings;
            let requestUrl, serverUrl;
            for (let urlMapping of backendUrlMappings) {
                if (request.url.startsWith(urlMapping.mapping)) {
                    serverUrl = urlMapping.url;
                    if (serverUrl.endsWith('/')) {
                        serverUrl = serverUrl.substring(0, serverUrl.length - 1);
                    }
                    requestUrl = request.url.replace(urlMapping.mapping, serverUrl);
                    break;
                }
            }
            request = request.clone({ url: requestUrl });
        }
        return next.handle(request);
    }
};
ApiPrefixInterceptor.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['environment',] }] }
];
ApiPrefixInterceptor = __decorate([
    Injectable(),
    __param(0, Inject('environment')),
    __metadata("design:paramtypes", [Object])
], ApiPrefixInterceptor);

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */
const TOKEN_EXPIRY_COOKIE_NAME = 'X-SEC-TK-EXP';
const TOKEN_COOKIE_NAME = 'X-SEC-TK';
const CONTENT_TYPE_HEADER_NAME = 'Content-Type';
const USER_STORAGE_ITEM_KEY = 'currentUser';
const log$3 = new Logger('Login');
const PUBLIC_URL_PATTERNS = 'PUBLIC_URL_PATTERNS';
const LOGIN_URL = 'LOGIN_URL';
let JwtInterceptor = class JwtInterceptor {
    constructor(cookieService, router, environment, publicUrlPatterns = [], loginUrl = '/login.html') {
        this.cookieService = cookieService;
        this.router = router;
        this.environment = environment;
        this.publicUrlPatterns = publicUrlPatterns;
        this.loginUrl = loginUrl;
        this.tokenExpiryDateTimerSubscription = null;
    }
    intercept(request, next) {
        let headers = request.headers;
        if (request.headers.get(CONTENT_TYPE_HEADER_NAME) == null) {
            headers = request.headers.append(CONTENT_TYPE_HEADER_NAME, 'application/json');
        }
        else if (request.headers.get(CONTENT_TYPE_HEADER_NAME).startsWith("multipart/form-data")) {
            headers = request.headers.delete(CONTENT_TYPE_HEADER_NAME);
        }
        let currentUser = JSON.parse(localStorage.getItem(USER_STORAGE_ITEM_KEY));
        if (currentUser && this.tokenExpiryDateTimerSubscription == null) {
            this.refreshTokenTimer();
        }
        request = request.clone({ headers });
        const started = Date.now();
        return next.handle(request).pipe(map(event => {
            if (event instanceof HttpResponse) {
                if (!this.environment.production) {
                    const elapsed = Date.now() - started;
                    console.log(`Request for ${request.urlWithParams} took ${elapsed} ms.`);
                }
                if (this.cookieService.get(TOKEN_EXPIRY_COOKIE_NAME)) {
                    console.log(`found ${TOKEN_EXPIRY_COOKIE_NAME} with value [${this.cookieService.get(TOKEN_EXPIRY_COOKIE_NAME)}]`);
                    if (this.tokenExpiryDateTimerSubscription) {
                        this.tokenExpiryDateTimerSubscription.unsubscribe();
                        this.refreshTokenTimer();
                    }
                }
            }
            return event;
        }));
    }
    refreshTokenTimer() {
        let isPublicUrl = false;
        this.publicUrlPatterns.forEach((urlPattern) => {
            isPublicUrl = isPublicUrl || this.router.url.startsWith(urlPattern);
        });
        if (isPublicUrl && !this.router.url.startsWith(this.loginUrl)) {
            // do nothing
            log$3.debug('skipping public url...');
            return;
        }
        log$3.debug('secured url, setting timer...');
        let tokenExpiry = this.cookieService.get(TOKEN_EXPIRY_COOKIE_NAME);
        this.tokenExpiryDateTimerSubscription = timer(tokenExpiry).subscribe(() => {
            localStorage.removeItem(USER_STORAGE_ITEM_KEY);
            this.cookieService.delete(TOKEN_EXPIRY_COOKIE_NAME);
            this.cookieService.delete(TOKEN_COOKIE_NAME);
            this.router.navigate([this.loginUrl], { replaceUrl: true });
        });
    }
};
JwtInterceptor.ctorParameters = () => [
    { type: CookieService },
    { type: Router },
    { type: undefined, decorators: [{ type: Inject, args: ['environment',] }] },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [PUBLIC_URL_PATTERNS,] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [LOGIN_URL,] }] }
];
JwtInterceptor = __decorate([
    Injectable(),
    __param(2, Inject('environment')),
    __param(3, Optional()), __param(3, Inject(PUBLIC_URL_PATTERNS)),
    __param(4, Optional()), __param(4, Inject(LOGIN_URL)),
    __metadata("design:paramtypes", [CookieService, Router, Object, Array, String])
], JwtInterceptor);

const CSRF_HEADER_NAME = 'X-XSRF-TOKEN';
let CsrfInterceptor = class CsrfInterceptor {
    constructor(cookieService, router, tokenExtractor) {
        this.cookieService = cookieService;
        this.router = router;
        this.tokenExtractor = tokenExtractor;
    }
    intercept(request, next) {
        const token = this.tokenExtractor.getToken();
        // add authorization header with jwt token if available
        let headers = request.headers;
        if (token != null && request.headers.get(CSRF_HEADER_NAME) == null && request.method == 'POST') {
            headers = request.headers.append(CSRF_HEADER_NAME, token);
        }
        request = request.clone({ headers });
        return next.handle(request);
    }
};
CsrfInterceptor.ctorParameters = () => [
    { type: CookieService },
    { type: Router },
    { type: HttpXsrfTokenExtractor }
];
CsrfInterceptor = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [CookieService, Router, HttpXsrfTokenExtractor])
], CsrfInterceptor);

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */
const log$4 = new Logger('MockInterceptor');
let MockInterceptor = class MockInterceptor {
    constructor(environment) {
        this.environment = environment;
    }
    intercept(request, next) {
        // if mock is not enabled or we are not in dev environment, then do nothing
        if (!this.environment.mock || !this.environment.dev) {
            return next.handle(request);
        }
        log$4.debug('################## Mock is enabled');
        // array in local storage for registered users
        let users = JSON.parse(localStorage.getItem('users')) || [];
        // wrap in delayed observable to simulate server api call
        return of(null).pipe(mergeMap(() => {
            // authenticate
            if (request.url.indexOf('/api/auth/login') != -1 && request.method === 'POST') {
                // if login details are valid return 200 OK with user details and fake jwt token
                let body = {
                    authorities: [{ "authority": "DQS_ADMIN" }],
                    principal: "admin",
                    name: "admin"
                };
                return of(new HttpResponse({ status: 200, body: body }));
            }
            // logout
            if (request.url.indexOf('/api/auth/logout') != -1 && request.method === 'POST') {
                // if login details are valid return 200 OK with user details and fake jwt token
                return of(new HttpResponse({ status: 200, body: 'true' }));
            }
            // get users
            if (request.url.indexOf('/api/users/list') != -1 && request.method === 'GET') {
                // check for fake auth token in header and return users if valid, this security is implemented server side in a real application
                users = JSON.parse('{"content":[{"id":21,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444444,"userName":"qweqwe","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251767000,"authorities":[{"id":21,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":22,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444445,"userName":"qweqwer","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251787000,"authorities":[{"id":22,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":23,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444446,"userName":"qweqwerq","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251908000,"authorities":[{"id":23,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":24,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444447,"userName":"qweqwerw","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251909000,"authorities":[{"id":24,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":25,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444448,"userName":"qweqwere","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251909000,"authorities":[{"id":25,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":26,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444449,"userName":"qweqwerr","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251909000,"authorities":[{"id":26,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":27,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444450,"userName":"qweqwert","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251909000,"authorities":[{"id":27,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":28,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444452,"userName":"qweqweru","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251910000,"authorities":[{"id":28,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":29,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444451,"userName":"qweqwery","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251910000,"authorities":[{"id":29,"authority":"DQS_USER"}],"tokenExpiryDate":null},{"id":30,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444454,"userName":"qweqwero","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251910000,"authorities":[{"id":30,"authority":"DQS_USER"}],"tokenExpiryDate":null}],"pageable":{"sort":{"sorted":false,"unsorted":true,"empty":true},"pageNumber":2,"pageSize":10,"offset":20,"unpaged":false,"paged":true},"last":false,"totalPages":8,"totalElements":71,"sort":{"sorted":false,"unsorted":true,"empty":true},"first":false,"numberOfElements":10,"size":10,"number":2,"empty":false}');
                return of(new HttpResponse({ status: 200, body: users }));
            }
            // get user details
            if (request.url.indexOf('/api/users/find') != -1 && request.method === 'GET') {
                // check for fake auth token in header and return users if valid, this security is implemented server side in a real application
                let body = JSON.parse('{"id":22,"dateOfBirthGregorian":null,"dateOfBirthHijri":14401010,"email":"myemail@mycompany.com","familyName":"MyFamilyName","firstName":"MyFirstName","gender":"M","grandFatherName":null,"subtribeName":null,"fatherName":null,"lastLoginDate":null,"mobileNumber":555555555,"nin":1234444445,"userName":"qweqwer","avatarFile":null,"avatar":null,"numberOfTries":0,"password":"<CONFIDENTIAL>","passwordHash":"<CONFIDENTIAL>","preferredLanguage":null,"updateDate":null,"deleted":false,"activated":true,"blockDate":null,"blocked":false,"changePasswordRequired":false,"creationDate":1548251787000,"authorities":[{"id":22,"authority":"DQS_USER"}],"tokenExpiryDate":null}');
                return of(new HttpResponse({ status: 200, body: body }));
            }
            // pass through any requests not handled above
            return next.handle(request);
        }))
            // call materialize and dematerialize to ensure delay even if an error is thrown (https://github.com/Reactive-Extensions/RxJS/issues/648)
            .pipe(materialize())
            .pipe(delay(500))
            .pipe(dematerialize());
    }
};
MockInterceptor.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['environment',] }] }
];
MockInterceptor = __decorate([
    Injectable(),
    __param(0, Inject('environment')),
    __metadata("design:paramtypes", [Object])
], MockInterceptor);

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */
var HttpService_1;
// From @angular/common/http/src/interceptor: allows to chain interceptors
class HttpInterceptorHandler {
    constructor(next, interceptor) {
        this.next = next;
        this.interceptor = interceptor;
    }
    handle(request) {
        return this.interceptor.intercept(request, this.next);
    }
}
/**
 * Allows to override default dynamic interceptors that can be disabled with the HttpService extension.
 * Except for very specific needs, you should better configure these interceptors directly in the constructor below
 * for better readability.
 *
 * For static interceptors that should always be enabled (like ApiPrefixInterceptor), use the standard
 * HTTP_INTERCEPTORS token.
 */
const HTTP_DYNAMIC_INTERCEPTORS = new InjectionToken('HTTP_DYNAMIC_INTERCEPTORS');
/**
 * Extends HttpClient with per request configuration using dynamic interceptors.
 */
let HttpService = HttpService_1 = class HttpService extends HttpClient {
    constructor(httpHandler, injector, interceptors = []) {
        super(httpHandler);
        this.httpHandler = httpHandler;
        this.injector = injector;
        this.interceptors = interceptors;
        if (!this.interceptors) {
            // Configure default interceptors that can be disabled here
            this.interceptors = [
                this.injector.get(ApiPrefixInterceptor),
                this.injector.get(ErrorHandlerInterceptor),
                this.injector.get(MockInterceptor),
                this.injector.get(JwtInterceptor),
                this.injector.get(CsrfInterceptor)
            ];
        }
    }
    cache(forceUpdate) {
        const cacheInterceptor = this.injector.get(CacheInterceptor).configure({ update: forceUpdate });
        return this.addInterceptor(cacheInterceptor);
    }
    skipErrorHandler() {
        return this.removeInterceptor(ErrorHandlerInterceptor);
    }
    disableApiPrefix() {
        return this.removeInterceptor(ApiPrefixInterceptor);
    }
    disableDefaultMock() {
        return this.removeInterceptor(MockInterceptor);
    }
    addMock(mockInterceptor) {
        return this.addInterceptor(mockInterceptor);
    }
    // Override the original method to wire interceptors when triggering the request.
    request(method, url, options) {
        const handler = this.interceptors.reduceRight((next, interceptor) => new HttpInterceptorHandler(next, interceptor), this.httpHandler);
        return new HttpClient(handler).request(method, url, options);
    }
    removeInterceptor(interceptorType) {
        return new HttpService_1(this.httpHandler, this.injector, this.interceptors.filter(i => !(i instanceof interceptorType)));
    }
    addInterceptor(interceptor) {
        return new HttpService_1(this.httpHandler, this.injector, this.interceptors.concat([interceptor]));
    }
};
HttpService.ctorParameters = () => [
    { type: HttpHandler },
    { type: Injector },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [HTTP_DYNAMIC_INTERCEPTORS,] }] }
];
HttpService = HttpService_1 = __decorate([
    Injectable(),
    __param(2, Optional()), __param(2, Inject(HTTP_DYNAMIC_INTERCEPTORS)),
    __metadata("design:paramtypes", [HttpHandler,
        Injector, Array])
], HttpService);

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */
var DccCommonsNgServicesModule_1;
const I18N_FOLDER_PATH = './assets/i18n/';
const ɵ0 = (HttpLoaderFactory);
let DccCommonsNgServicesModule = DccCommonsNgServicesModule_1 = class DccCommonsNgServicesModule {
    constructor(parentModule) {
        // Import guard
        if (parentModule) {
            throw new Error(`${parentModule} has already been loaded. Import Services module in the AppModule only.`);
        }
    }
    static forRoot(publicUrlPatterns = [], loginUrl, i18nFolderPath) {
        return {
            ngModule: DccCommonsNgServicesModule_1,
            providers: [
                { provide: PUBLIC_URL_PATTERNS, useValue: publicUrlPatterns },
                { provide: LOGIN_URL, useValue: loginUrl },
                { provide: I18N_FOLDER_PATH, useValue: i18nFolderPath }
            ]
        };
    }
};
DccCommonsNgServicesModule.ctorParameters = () => [
    { type: DccCommonsNgServicesModule, decorators: [{ type: Optional }, { type: SkipSelf }] }
];
__decorate([
    __param(0, Optional()), __param(1, Optional()), __param(2, Optional()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, String, String]),
    __metadata("design:returntype", Object)
], DccCommonsNgServicesModule, "forRoot", null);
DccCommonsNgServicesModule = DccCommonsNgServicesModule_1 = __decorate([
    NgModule({
        imports: [
            CommonModule,
            HttpClientModule,
            TranslateModule.forRoot({
                loader: {
                    provide: TranslateLoader,
                    useFactory: ɵ0,
                    deps: [HttpClient, I18N_FOLDER_PATH]
                }
            }),
            RouterModule
        ],
        declarations: [],
        providers: [
            I18nService,
            HttpCacheService,
            ApiPrefixInterceptor,
            ErrorHandlerInterceptor,
            CacheInterceptor,
            CookieService,
            JwtInterceptor,
            CsrfInterceptor,
            MockInterceptor,
            {
                provide: HttpClient,
                useClass: HttpService
            },
            {
                provide: RouteReuseStrategy,
                useClass: RouteReusableStrategy
            }
        ]
    }),
    __param(0, Optional()), __param(0, SkipSelf()),
    __metadata("design:paramtypes", [DccCommonsNgServicesModule])
], DccCommonsNgServicesModule);
function HttpLoaderFactory(http, i18nFolderPath) {
    return new TranslateHttpLoader(http, i18nFolderPath, '.json');
}

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */
const RouteAnimations = trigger('routerAnimations', [
    transition('* <=> *', [
        // css styles at start of transition
        //style({ opacity: 0 }),
        // animation and styles at end of transition
        //animate('0.5s', style({ opacity: 1 }))
        query(':enter, :leave', style({ position: 'fixed', width: '100%' }), { optional: true }),
        query(':enter', style({ transform: 'translateX(100%)' }), { optional: true }),
        sequence([
            query(':leave', animateChild(), { optional: true }),
            group([
                query(':leave', [
                    style({ transform: 'translateX(0%)' }),
                    animate('500ms cubic-bezier(.75,-0.48,.26,1.52)', style({ transform: 'translateX(-100%)' }))
                ], { optional: true }),
                query(':enter', [
                    style({ transform: 'translateX(100%)' }),
                    animate('500ms cubic-bezier(.75,-0.48,.26,1.52)', style({ transform: 'translateX(0%)' }))
                ], { optional: true }),
            ]),
            query(':enter', animateChild(), { optional: true }),
        ])
    ])
]);
/**
 * Provides helper methods to create routes.
 */
class Route {
    /**
     * Creates routes using the shell component and authentication.
     * @param routes The routes to add.
     * @return {Route} The new route using shell as the base.
     */
    static withShell(routes, appLayout, authGuard) {
        return {
            path: '',
            component: appLayout,
            children: routes,
            canActivate: [authGuard],
            // Reuse ShellComponent instance when navigating between child views
            data: { reuse: true }
        };
    }
}

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */

/*
 * Copyright (c) 2019 ELM. All rights reserved.
 */

/*
 * Public API Surface of services
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ApiPrefixInterceptor, CacheInterceptor, CsrfInterceptor, DccCommonsNgServicesModule, ErrorHandlerInterceptor, HTTP_DYNAMIC_INTERCEPTORS, HttpCacheService, HttpLoaderFactory, HttpService, I18N_FOLDER_PATH, I18nService, JwtInterceptor, LOGIN_URL, LogLevel, Logger, MockInterceptor, PUBLIC_URL_PATTERNS, Route, RouteAnimations, RouteReusableStrategy, extract, ɵ0, I18nService as ɵa, HttpCacheService as ɵb, ApiPrefixInterceptor as ɵc, ErrorHandlerInterceptor as ɵd, CacheInterceptor as ɵe, PUBLIC_URL_PATTERNS as ɵf, LOGIN_URL as ɵg, JwtInterceptor as ɵh, CsrfInterceptor as ɵi, MockInterceptor as ɵj, HTTP_DYNAMIC_INTERCEPTORS as ɵk, HttpService as ɵl, RouteReusableStrategy as ɵm };
//# sourceMappingURL=dcc-commons-ng-services.js.map
